/** @file

  VerPartitionLib - VER partition library

  Copyright (c) 2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.

  SPDX-License-Identifier: BSD-2-Clause-Patent

**/
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/VerPartitionLib.h>
#include <Library/MemoryAllocationLib.h>

//
// VER partition format
//
// NV4: VersionID,ReleaseString,BoardID,Timestamp,Version32,CRC32
//
// Example VER partition contents generated by flash.sh:
//
// NV4
// # RBRANCH_NUM , REVISION: MAJ_NUM.MIN_NUM
// BOARDID=2888 BOARDSKU=0001 FAB=400
// 20210603224448
// 0x00200601
// BYTES:107 CRC32:4EFF24B8
//

#define VERSION_STR_ID     "NV4"
#define VERSION_STR_CRC32  "CRC32:"

#define VERSION_STRING_LINE  2
#define VERSION32_LINE       5
#define VERSION_CRC32_LINE   6

/**
  Return pointer to given line number in string

  @param[in]      String            Input string
  @param[in]      LineNumber        Line number to find

  @retval         NULL              Line number not found
  @retval         Others            Pointer to beginning of requested line

**/
STATIC
CONST CHAR8 *
EFIAPI
AsciiFindLine (
  IN  CONST CHAR8  *String,
  IN  UINTN        LineNumber
  )
{
  UINTN        Index;
  CONST CHAR8  *Line;

  Line = String;
  for (Index = 1; Index < LineNumber; Index++) {
    Line = AsciiStrStr (Line, "\n");
    if (Line == NULL) {
      break;
    }

    Line++;
  }

  return Line;
}

EFI_STATUS
EFIAPI
VerPartitionGetVersion (
  IN  VOID    *Data,
  IN  UINTN   DataLen,
  OUT UINT32  *Version,
  OUT CHAR8   **VersionString
  )
{
  CONST CHAR8  *VerData;
  CONST CHAR8  *EndOfData;
  CONST CHAR8  *Line;
  CONST CHAR8  *EndOfLine;
  UINTN        LineLength;
  CONST CHAR8  *CrcStr;
  UINT32       CrcExpected;
  UINT32       CrcReceived;
  UINT64       Version64;
  EFI_STATUS   Status;

  VerData        = (CHAR8 *)Data;
  EndOfData      = VerData + DataLen;
  *VersionString = NULL;

  // check for supported format
  if (AsciiStrnCmp (VerData, VERSION_STR_ID, AsciiStrLen (VERSION_STR_ID)) != 0) {
    DEBUG ((
      DEBUG_ERROR,
      "%a: version id is not %a\n",
      __FUNCTION__,
      VERSION_STR_ID
      ));
    return EFI_UNSUPPORTED;
  }

  // validate CRC
  Line = AsciiFindLine (VerData, VERSION_CRC32_LINE);
  if (Line == NULL) {
    DEBUG ((DEBUG_ERROR, "%a: Line %u missing\n", __FUNCTION__, VERSION_CRC32_LINE));
    return EFI_VOLUME_CORRUPTED;
  }

  CrcReceived = CalculateCrc32 ((VOID *)VerData, Line - VerData);

  CrcStr = AsciiStrStr (Line, VERSION_STR_CRC32);
  if (CrcStr == NULL) {
    DEBUG ((
      DEBUG_ERROR,
      "%a: No '%a' string on line %u\n",
      __FUNCTION__,
      VERSION_STR_CRC32,
      VERSION_CRC32_LINE
      ));
    return EFI_INVALID_PARAMETER;
  }

  CrcStr += AsciiStrLen (VERSION_STR_CRC32);
  if (CrcStr >= EndOfData) {
    return EFI_INVALID_PARAMETER;
  }

  CrcExpected = AsciiStrHexToUintn (CrcStr);
  if (CrcExpected != CrcReceived) {
    DEBUG ((
      DEBUG_ERROR,
      "%a: Crc mismatch expected=0x%x, received=0x%x\n",
      __FUNCTION__,
      CrcExpected,
      CrcReceived
      ));
    return EFI_VOLUME_CORRUPTED;
  }

  // make a copy of the version string
  Line = AsciiFindLine (VerData, VERSION_STRING_LINE);
  if (Line == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  EndOfLine  = AsciiStrStr (Line, "\n");
  LineLength = EndOfLine - Line;

  *VersionString = (CHAR8 *)AllocatePool (LineLength + 1);
  if (*VersionString == NULL) {
    return EFI_OUT_OF_RESOURCES;
  }

  CopyMem (*VersionString, Line, LineLength);
  (*VersionString)[LineLength] = '\0';

  // extract the 32-bit version
  Line = AsciiFindLine (VerData, VERSION32_LINE);
  if (Line == NULL) {
    Status = EFI_INVALID_PARAMETER;
    goto Done;
  }

  Version64 = AsciiStrHexToUint64 (Line);
  if (Version64 > MAX_UINT32) {
    Status = EFI_INVALID_PARAMETER;
    goto Done;
  }

  *Version =  (UINT32)Version64;
  Status   = EFI_SUCCESS;

Done:
  if (EFI_ERROR (Status)) {
    if (*VersionString != NULL) {
      FreePool (*VersionString);
      *VersionString = NULL;
    }

    return Status;
  }

  DEBUG ((
    DEBUG_INFO,
    "%a: Crc=0x%x Version=0x%x (%a)\n",
    __FUNCTION__,
    CrcExpected,
    *Version,
    *VersionString
    ));

  return EFI_SUCCESS;
}
