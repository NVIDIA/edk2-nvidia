/** @file

  VerPartitionLib - VER partition library

  Copyright (c) 2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.

  SPDX-License-Identifier: BSD-2-Clause-Patent

**/
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/VerPartitionLib.h>
#include <Library/MemoryAllocationLib.h>

//
// VER partition format
//
// NV4: VersionID,ReleaseString,BoardID,Timestamp,Version32,CRC32
//
// Example VER partition contents generated by flash.sh:
//
// NV4
// # RBRANCH_NUM , REVISION: MAJ_NUM.MIN_NUM
// BOARDID=2888 BOARDSKU=0001 FAB=400
// 20210603224448
// 0x00200601
// BYTES:107 CRC32:4EFF24B8
//

#define VERSION_STR_ID          "NV4"
#define VERSION_STR_CRC32       "CRC32:"

#define VERSION_STRING_LINE     2
#define VERSION32_LINE          5
#define VERSION_CRC32_LINE      6

/**
  Return pointer to given line number in string

  @param[in]      String            Input string
  @param[in]      LineNumber        Line number to find

  @retval         NULL              Line number not found
  @retval         Others            Pointer to beginning of requested line

**/
STATIC
CONST CHAR8 *
EFIAPI
AsciiFindLine (
  IN  CONST CHAR8   *String,
  IN  UINTN         LineNumber
  )
{
  UINTN         Index;
  CONST CHAR8   *Line;

  Line = String;
  for (Index = 1; Index < LineNumber; Index++) {
    Line = AsciiStrStr (Line, "\n");
    if (Line == NULL) {
      break;
    }
    Line++;
  }

  return Line;
}

EFI_STATUS
EFIAPI
VerPartitionGetVersion (
  IN  VOID          *Data,
  IN  UINTN         DataLen,
  OUT UINT32        *Version,
  OUT CHAR8         **VersionString
  )
{
  CONST CHAR8   *VerData;
  CONST CHAR8   *EndOfData;
  CONST CHAR8   *Line;
  CONST CHAR8   *EndOfLine;
  UINTN         LineLength;
  CONST CHAR8   *CrcStr;
  UINT32        CrcExpected;
  UINT32        CrcReceived;
  UINT64        Version64;
  EFI_STATUS    Status;

  VerData = (CHAR8 *) Data;
  EndOfData = VerData + DataLen;
  *VersionString = NULL;

  // check for supported format
  if (AsciiStrnCmp (VerData, VERSION_STR_ID, AsciiStrLen (VERSION_STR_ID)) != 0) {
    DEBUG ((DEBUG_ERROR, "%a: version id is not %a\n",
            __FUNCTION__, VERSION_STR_ID));
    return EFI_UNSUPPORTED;
  }

  // validate CRC
  Line = AsciiFindLine (VerData, VERSION_CRC32_LINE);
  if (Line == NULL) {
    DEBUG ((DEBUG_ERROR, "%a: Line %u missing\n", __FUNCTION__, VERSION_CRC32_LINE));
    return EFI_VOLUME_CORRUPTED;
  }
  CrcReceived = CalculateCrc32 ((VOID *)VerData, Line - VerData);

  CrcStr = AsciiStrStr (Line, VERSION_STR_CRC32);
  if (CrcStr == NULL) {
    DEBUG ((DEBUG_ERROR, "%a: No '%a' string on line %u\n",
            __FUNCTION__, VERSION_STR_CRC32, VERSION_CRC32_LINE));
    return EFI_INVALID_PARAMETER;
  }

  CrcStr += AsciiStrLen (VERSION_STR_CRC32);
  if (CrcStr >= EndOfData) {
    return EFI_INVALID_PARAMETER;
  }

  CrcExpected = AsciiStrHexToUintn (CrcStr);
  if (CrcExpected != CrcReceived) {
    DEBUG ((DEBUG_ERROR, "%a: Crc mismatch expected=0x%x, received=0x%x\n",
            __FUNCTION__, CrcExpected, CrcReceived));
    return EFI_VOLUME_CORRUPTED;
  }

  // make a copy of the version string
  Line = AsciiFindLine (VerData, VERSION_STRING_LINE);
  if (Line == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  EndOfLine = AsciiStrStr (Line, "\n");
  LineLength = EndOfLine - Line;

  *VersionString = (CHAR8 *) AllocatePool (LineLength + 1);
  if (*VersionString == NULL) {
    return EFI_OUT_OF_RESOURCES;
  }

  CopyMem (*VersionString, Line, LineLength);
  (*VersionString)[LineLength] = '\0';

  // extract the 32-bit version
  Line = AsciiFindLine (VerData, VERSION32_LINE);
  if (Line == NULL) {
    Status = EFI_INVALID_PARAMETER;
    goto Done;
  }

  Version64 = AsciiStrHexToUint64 (Line);
  if (Version64 > MAX_UINT32) {
    Status = EFI_INVALID_PARAMETER;
    goto Done;
  }

  *Version =  (UINT32) Version64;
  Status = EFI_SUCCESS;

Done:
  if (EFI_ERROR (Status)) {
    if (*VersionString != NULL) {
      FreePool (*VersionString);
      *VersionString = NULL;
    }

    return Status;
  }

  DEBUG ((DEBUG_INFO, "%a: Crc=0x%x Version=0x%x (%a)\n",
          __FUNCTION__, CrcExpected, *Version, *VersionString));

  return EFI_SUCCESS;
}
