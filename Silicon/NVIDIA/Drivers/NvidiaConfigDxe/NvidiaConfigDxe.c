/** @file
*  NVIDIA Configuration Dxe
*
*  SPDX-FileCopyrightText: Copyright (c) 2020-2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
*  Copyright (c) 2017, Linaro, Ltd. All rights reserved.
*
*  SPDX-License-Identifier: BSD-2-Clause-Patent
*
**/

#include <Guid/MdeModuleHii.h>
#include <Guid/HiiPlatformSetupFormset.h>

#include <Protocol/ComponentName2.h>
#include <Protocol/HiiConfigAccess.h>
#include <Protocol/HiiConfigRouting.h>
#include <Protocol/MmCommunication2.h>
#include <Protocol/PciIo.h>
#include <Protocol/ServerPowerControl.h>

#include <Library/PrintLib.h>
#include <Library/DebugLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiRuntimeServicesTableLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/BaseLib.h>
#include <Library/FloorSweepingLib.h>
#include <Library/HiiLib.h>
#include <Library/HobLib.h>
#include <Library/IoLib.h>
#include <Library/DevicePathLib.h>
#include <Library/DeviceTreeHelperLib.h>
#include <Library/PcdLib.h>
#include <Library/PrintLib.h>
#include <Library/UefiHiiServicesLib.h>
#include <Library/UefiLib.h>
#include <Library/VariablePolicyHelperLib.h>
#include <Library/FwVariableLib.h>
#include <Library/PlatformResourceLib.h>
#include <Library/StatusRegLib.h>
#include <Library/TegraSerialPortLib.h>

#include <IndustryStandard/Pci22.h>

#include <Guid/NVIDIAMmMb1Record.h>
#include <TH500/TH500Definitions.h>
#include <TH500/TH500MB1Configuration.h>
#include "Base.h"
#include "NvidiaConfigHii.h"
#include "ProcessorBind.h"
#include "Uefi/UefiBaseType.h"

#define OS_CONFIG_VAR_ATTRIBUTES    (EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_RUNTIME_ACCESS)
#define UEFI_CONFIG_VAR_ATTRIBUTES  (EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS)

extern EFI_GUID  gNVIDIAResourceConfigFormsetGuid;

/**
  Get total enabled cores count of all sockets

  @return UINT32         Total number of enabled cores
**/
UINT32
GetTotalEnabledCores (
  );

//
// These are the VFR compiler generated data representing our VFR data.
//
extern UINT8  NvidiaConfigHiiBin[];
extern UINT8  NvidiaConfigDxeStrings[];

// Used to make sure autogen isn't too smart
EFI_STRING_ID  UnusedStringArray[] = {
  STRING_TOKEN (STR_SOCKET0_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_SOCKET0_CONFIG_FORM_HELP),
  STRING_TOKEN (STR_SOCKET1_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_SOCKET1_CONFIG_FORM_HELP),
  STRING_TOKEN (STR_SOCKET2_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_SOCKET2_CONFIG_FORM_HELP),
  STRING_TOKEN (STR_SOCKET3_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_SOCKET3_CONFIG_FORM_HELP),
  STRING_TOKEN (STR_SPREAD_SPECTRUM_PROMPT),
  STRING_TOKEN (STR_SPREAD_SPECTRUM_HELP),
  STRING_TOKEN (STR_MODS_SP_ENABLE_PROMPT),
  STRING_TOKEN (STR_MODS_SP_ENABLE_HELP),
  STRING_TOKEN (STR_GPU_SMMU_BYPASS_ENABLE_PROMPT),
  STRING_TOKEN (STR_GPU_SMMU_BYPASS_ENABLE_HELP),
  STRING_TOKEN (STR_UART_BAUD_RATE_PROMPT),
  STRING_TOKEN (STR_UART_BAUD_RATE_HELP),
  STRING_TOKEN (STR_PERF_VERSION_PROMPT),
  STRING_TOKEN (STR_PERF_VERSION_HELP),
  STRING_TOKEN (STR_EINJ_ENABLE_PROMPT),
  STRING_TOKEN (STR_EINJ_ENABLE_HELP),
  STRING_TOKEN (STR_DISABLE_CHANNEL_SPARING_PROMPT),
  STRING_TOKEN (STR_DISABLE_CHANNEL_SPARING_HELP),
  STRING_TOKEN (STR_ECC_ALGORITHM_PROMPT),
  STRING_TOKEN (STR_ECC_ALGORITHM_HELP),
  STRING_TOKEN (STR_MAX_ALLOWED_NUM_SPARES_PROMPT),
  STRING_TOKEN (STR_MAX_ALLOWED_NUM_SPARES_HELP),
  STRING_TOKEN (STR_MAX_CORES_PROMPT),
  STRING_TOKEN (STR_MAX_CORES_HELP),
  STRING_TOKEN (STR_SERVER_POWER_CONTROL_PROMPT),
  STRING_TOKEN (STR_SERVER_POWER_CONTROL_HELP),
  STRING_TOKEN (NVIDIA_SERVER_POWER_CTL_INPUT_PWR_CAPPING_50MS),
  STRING_TOKEN (NVIDIA_SERVER_POWER_CTL_INPUT_PWR_CAPPING_1S),
  STRING_TOKEN (NVIDIA_SERVER_POWER_CTL_INPUT_PWR_CAPPING_5S),
  STRING_TOKEN (STR_UPHY0_SOCKET0_PROMPT),
  STRING_TOKEN (STR_UPHY0_SOCKET1_PROMPT),
  STRING_TOKEN (STR_UPHY0_SOCKET2_PROMPT),
  STRING_TOKEN (STR_UPHY0_SOCKET3_PROMPT),
  STRING_TOKEN (STR_UPHY0_HELP),
  STRING_TOKEN (STR_PCIE_C0_X16),
  STRING_TOKEN (STR_PCIE_C0_X8_C1_X8),
  STRING_TOKEN (STR_UPHY1_SOCKET0_PROMPT),
  STRING_TOKEN (STR_UPHY1_SOCKET1_PROMPT),
  STRING_TOKEN (STR_UPHY1_SOCKET2_PROMPT),
  STRING_TOKEN (STR_UPHY1_SOCKET3_PROMPT),
  STRING_TOKEN (STR_UPHY1_HELP),
  STRING_TOKEN (STR_PCIE_C2_X16),
  STRING_TOKEN (STR_PCIE_C2_X8_C3_X8),
  STRING_TOKEN (STR_UPHY2_SOCKET0_PROMPT),
  STRING_TOKEN (STR_UPHY2_SOCKET1_PROMPT),
  STRING_TOKEN (STR_UPHY2_SOCKET2_PROMPT),
  STRING_TOKEN (STR_UPHY2_SOCKET3_PROMPT),
  STRING_TOKEN (STR_UPHY2_HELP),
  STRING_TOKEN (STR_PCIE_C4_X16),
  STRING_TOKEN (STR_PCIE_C4_X8_C5_X8),
  STRING_TOKEN (STR_PCIE_C5_X4_NVLINK_X12),
  STRING_TOKEN (STR_PCIE_C5_X4_NVLINK_NO_PCIE),
  STRING_TOKEN (STR_UPHY3_SOCKET0_PROMPT),
  STRING_TOKEN (STR_UPHY3_SOCKET1_PROMPT),
  STRING_TOKEN (STR_UPHY3_SOCKET2_PROMPT),
  STRING_TOKEN (STR_UPHY3_SOCKET3_PROMPT),
  STRING_TOKEN (STR_UPHY3_HELP),
  STRING_TOKEN (STR_PCIE_C6_X16),
  STRING_TOKEN (STR_PCIE_C6_X8_C7_X8),
  STRING_TOKEN (STR_PCIE_C7_X4_NVLINK_X12),
  STRING_TOKEN (STR_PCIE_C7_X4_NVLINK_NO_PCIE),
  STRING_TOKEN (STR_UPHY4_SOCKET0_PROMPT),
  STRING_TOKEN (STR_UPHY4_SOCKET1_PROMPT),
  STRING_TOKEN (STR_UPHY4_SOCKET2_PROMPT),
  STRING_TOKEN (STR_UPHY4_SOCKET3_PROMPT),
  STRING_TOKEN (STR_UPHY4_HELP),
  STRING_TOKEN (STR_PCIE_C8_X2),
  STRING_TOKEN (STR_PCIE_C8_X1_USB),
  STRING_TOKEN (STR_UPHY5_SOCKET0_PROMPT),
  STRING_TOKEN (STR_UPHY5_SOCKET1_PROMPT),
  STRING_TOKEN (STR_UPHY5_SOCKET2_PROMPT),
  STRING_TOKEN (STR_UPHY5_SOCKET3_PROMPT),
  STRING_TOKEN (STR_UPHY5_HELP),
  STRING_TOKEN (STR_PCIE_C9_X2),
  STRING_TOKEN (STR_PCIE0_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE1_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE2_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE3_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE4_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE5_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE6_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE7_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE8_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE9_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_SPEED_HELP),
  STRING_TOKEN (STR_PCIE_GEN5),
  STRING_TOKEN (STR_PCIE_GEN4),
  STRING_TOKEN (STR_PCIE_GEN3),
  STRING_TOKEN (STR_PCIE_GEN2),
  STRING_TOKEN (STR_PCIE_GEN1),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_WIDTH_HELP),
  STRING_TOKEN (STR_PCIE_X16),
  STRING_TOKEN (STR_PCIE_X8),
  STRING_TOKEN (STR_PCIE_X4),
  STRING_TOKEN (STR_PCIE_X2),
  STRING_TOKEN (STR_PCIE_X1),
  STRING_TOKEN (STR_PCIE_128B),
  STRING_TOKEN (STR_PCIE_256B),
  STRING_TOKEN (STR_PCIE_512B),
  STRING_TOKEN (STR_PCIE_1024B),
  STRING_TOKEN (STR_PCIE_2048B),
  STRING_TOKEN (STR_PCIE_4096B),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_1_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ASPM_L1_2_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_PCIPM_L1_2_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_CLK_REQ_HELP),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DLFE_HELP),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ENABLE_ECRC_HELP),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_OPT_ROM_HELP),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_DPC_AT_RP_HELP),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SLOT_NUM_HELP),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_UNSUPPORTED_REQUEST_HELP),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MASK_COMPLETER_ABORT_HELP),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_SUPPORTS_PRSNT_HELP),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_ADVERTISE_ACS_HELP),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_MAX_PAYLOAD_SIZE_HELP),

  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_EXTENDED_10BIT_TAG_ENABLE_HELP),

  STRING_TOKEN (STR_MPAM_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_MPAM_CONFIG_FORM_HELP),
  STRING_TOKEN (STR_MPAM40_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_MPAM41_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_MPAM42_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_MPAM43_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_MPAM44_CONFIG_FORM_TITLE),
  STRING_TOKEN (STR_MPAM40_CPOR_WAYMASK_TITLE),
  STRING_TOKEN (STR_MPAM41_CPOR_WAYMASK_TITLE),
  STRING_TOKEN (STR_MPAM42_CPOR_WAYMASK_TITLE),
  STRING_TOKEN (STR_MPAM43_CPOR_WAYMASK_TITLE),
  STRING_TOKEN (STR_MPAM44_CPOR_WAYMASK_TITLE),
  STRING_TOKEN (STR_MPAM40_CPOR_WAYMASK_HELP),
  STRING_TOKEN (STR_MPAM41_CPOR_WAYMASK_HELP),
  STRING_TOKEN (STR_MPAM42_CPOR_WAYMASK_HELP),
  STRING_TOKEN (STR_MPAM43_CPOR_WAYMASK_HELP),
  STRING_TOKEN (STR_MPAM44_CPOR_WAYMASK_HELP),
  STRING_TOKEN (STR_MPAM40_MAX_BW_TITLE),
  STRING_TOKEN (STR_MPAM41_MAX_BW_TITLE),
  STRING_TOKEN (STR_MPAM42_MAX_BW_TITLE),
  STRING_TOKEN (STR_MPAM43_MAX_BW_TITLE),
  STRING_TOKEN (STR_MPAM44_MAX_BW_TITLE),
  STRING_TOKEN (STR_MPAM40_MAX_BW_HELP),
  STRING_TOKEN (STR_MPAM41_MAX_BW_HELP),
  STRING_TOKEN (STR_MPAM42_MAX_BW_HELP),
  STRING_TOKEN (STR_MPAM43_MAX_BW_HELP),
  STRING_TOKEN (STR_MPAM44_MAX_BW_HELP),
  STRING_TOKEN (STR_MPAM40_MIN_BW_TITLE),
  STRING_TOKEN (STR_MPAM41_MIN_BW_TITLE),
  STRING_TOKEN (STR_MPAM42_MIN_BW_TITLE),
  STRING_TOKEN (STR_MPAM43_MIN_BW_TITLE),
  STRING_TOKEN (STR_MPAM44_MIN_BW_TITLE),
  STRING_TOKEN (STR_MPAM40_MIN_BW_HELP),
  STRING_TOKEN (STR_MPAM41_MIN_BW_HELP),
  STRING_TOKEN (STR_MPAM42_MIN_BW_HELP),
  STRING_TOKEN (STR_MPAM43_MIN_BW_HELP),
  STRING_TOKEN (STR_MPAM44_MIN_BW_HELP),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_OS_NATIVE_AER_HELP),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET0_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET1_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET2_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE0_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE1_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE2_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE3_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE4_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE5_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE6_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE7_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE8_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_SOCKET3_PCIE9_TITLE),
  STRING_TOKEN (STR_PCIE_DISABLE_L23_AT_WARM_RESET_HELP),
};

STATIC UINT64  TH500SocketScratchBaseAddr[TH500_MAX_SOCKETS] = {
  TH500_SCRATCH_BASE_SOCKET_0,
  TH500_SCRATCH_BASE_SOCKET_1,
  TH500_SCRATCH_BASE_SOCKET_2,
  TH500_SCRATCH_BASE_SOCKET_3,
};

//
// HII specific Vendor Device Path definition.
//
typedef struct {
  VENDOR_DEVICE_PATH          VendorDevicePath;
  EFI_DEVICE_PATH_PROTOCOL    End;
} HII_VENDOR_DEVICE_PATH;

HII_VENDOR_DEVICE_PATH  mNvidiaConfigHiiVendorDevicePath = {
  {
    {
      HARDWARE_DEVICE_PATH,
      HW_VENDOR_DP,
      {
        (UINT8)(sizeof (VENDOR_DEVICE_PATH)),
        (UINT8)((sizeof (VENDOR_DEVICE_PATH)) >> 8)
      }
    },
    NVIDIA_CONFIG_FORMSET_GUID
  },
  {
    END_DEVICE_PATH_TYPE,
    END_ENTIRE_DEVICE_PATH_SUBTYPE,
    {
      (UINT8)(END_DEVICE_PATH_LENGTH),
      (UINT8)((END_DEVICE_PATH_LENGTH) >> 8)
    }
  }
};

EFI_HII_CONFIG_ACCESS_PROTOCOL         mConfigAccess;
CHAR16                                 mHiiControlStorageName[] = L"NVIDIA_CONFIG_HII_CONTROL";
NVIDIA_CONFIG_HII_CONTROL              mHiiControlSettings      = { 0 };
EFI_HANDLE                             mDriverHandle;
TEGRABL_EARLY_BOOT_VARIABLES           mMb1Config                   = { 0 };
TEGRABL_EARLY_BOOT_VARIABLES           mMb1DefaultConfig            = { 0 };
TEGRABL_EARLY_BOOT_VARIABLES           mLastWrittenMb1Config        = { 0 };
TEGRABL_EARLY_BOOT_VARIABLES           mVariableMb1Config           = { 0 };
STATIC EFI_MM_COMMUNICATION2_PROTOCOL  *mMmCommunicate2             = NULL;
STATIC VOID                            *mMmCommunicationBuffer      = NULL;
UINT64                                 mOpRomDisMask                = 0;
UINT32                                 mMaxPayloadSize[MAX_SOCKETS] = { 0 };
UINT64                                 mExt10bitTagReqEnable        = 0;
EFI_HII_HANDLE                         mHiiHandle;
UINT8                                  mDefaultPortConfig = NVIDIA_SERIAL_PORT_DISABLED;

// Print TEGRABL_EARLY_BOOT_VARIABLES
VOID
EFIAPI
PrintMb1Variables (
  TEGRABL_EARLY_BOOT_VARIABLES  *EarlyVariable
  )
{
  UINTN  Index;
  UINTN  Index2;

  DEBUG ((DEBUG_ERROR, "---------MB1 Variable Printout---------\n"));
  DEBUG ((DEBUG_ERROR, "Grace.MB1.FeatureData: %010x\n", EarlyVariable->Data.Mb1Data.FeatureData));
  DEBUG ((DEBUG_ERROR, "Grace.MB1.HvRsvdMemSize: %08x\n", EarlyVariable->Data.Mb1Data.HvRsvdMemSize));
  DEBUG ((DEBUG_ERROR, "Grace.MB1.UefiDebugLevel: %08x\n", EarlyVariable->Data.Mb1Data.UefiDebugLevel));

  for (Index = 0; Index < TEGRABL_SOC_MAX_SOCKETS; Index++) {
    if (!mHiiControlSettings.SocketEnabled[Index]) {
      continue;
    }

    for (Index2 = 0; Index2 < TEGRABL_MAX_UPHY_PER_SOCKET; Index2++) {
      DEBUG ((DEBUG_ERROR, "Grace.MB1.UphyConfig.%x.%x: 0x%02x\n", Index, Index2, EarlyVariable->Data.Mb1Data.UphyConfig.UphyConfig[Index][Index2]));
    }
  }

  for (Index = 0; Index < TEGRABL_SOC_MAX_SOCKETS; Index++) {
    if (!mHiiControlSettings.SocketEnabled[Index]) {
      continue;
    }

    for (Index2 = 0; Index2 < TEGRABL_MAX_PCIE_PER_SOCKET; Index2++) {
      DEBUG ((DEBUG_ERROR, "Grace.MB1.PcieConfig.%x.%x.Features: 0x%010x\n", Index, Index2, EarlyVariable->Data.Mb1Data.PcieConfig[Index][Index2].Features));
      DEBUG ((DEBUG_ERROR, "Grace.MB1.PcieConfig.%x.%x.MaxSpeed: 0x%08x\n", Index, Index2, EarlyVariable->Data.Mb1Data.PcieConfig[Index][Index2].MaxSpeed));
      DEBUG ((DEBUG_ERROR, "Grace.MB1.PcieConfig.%x.%x.MaxWidth: 0x%08x\n", Index, Index2, EarlyVariable->Data.Mb1Data.PcieConfig[Index][Index2].MaxWidth));
      DEBUG ((DEBUG_ERROR, "Grace.MB1.PcieConfig.%x.%x.SlotType: 0x%02x\n", Index, Index2, EarlyVariable->Data.Mb1Data.PcieConfig[Index][Index2].SlotType));
      DEBUG ((DEBUG_ERROR, "Grace.MB1.PcieConfig.%x.%x.SlotNum : 0x%04x\n", Index, Index2, EarlyVariable->Data.Mb1Data.PcieConfig[Index][Index2].SlotNum));
    }
  }
}

// Talk to MB1 actual storage
EFI_STATUS
EFIAPI
AccessMb1Record (
  TEGRABL_EARLY_BOOT_VARIABLES  *EarlyVariable,
  BOOLEAN                       Write
  )
{
  EFI_STATUS                    Status;
  EFI_MM_COMMUNICATE_HEADER     *Header;
  NVIDIA_MM_MB1_RECORD_PAYLOAD  *Payload;
  UINTN                         MmBufferSize;

  MmBufferSize = sizeof (EFI_MM_COMMUNICATE_HEADER) + sizeof (NVIDIA_MM_MB1_RECORD_PAYLOAD) - 1;

  if (mMmCommunicate2 == NULL) {
    Status = gBS->LocateProtocol (&gEfiMmCommunication2ProtocolGuid, NULL, (VOID **)&mMmCommunicate2);
    if (EFI_ERROR (Status)) {
      return Status;
    }

    if (mMmCommunicationBuffer == NULL) {
      mMmCommunicationBuffer = AllocateZeroPool (MmBufferSize);
      if (mMmCommunicationBuffer == NULL) {
        mMmCommunicate2 = NULL;
        DEBUG ((DEBUG_ERROR, "%a: Failed to allocate buffer \r\n", __FUNCTION__));
        return EFI_OUT_OF_RESOURCES;
      }
    }

    Header = (EFI_MM_COMMUNICATE_HEADER *)mMmCommunicationBuffer;
    CopyGuid (&Header->HeaderGuid, &gNVIDIAMmMb1RecordGuid);
    Header->MessageLength = sizeof (NVIDIA_MM_MB1_RECORD_PAYLOAD);
  }

  Header  = (EFI_MM_COMMUNICATE_HEADER *)mMmCommunicationBuffer;
  Payload = (NVIDIA_MM_MB1_RECORD_PAYLOAD *)&Header->Data;

  STATIC_ASSERT (
    sizeof (Payload->Data) >= sizeof (EarlyVariable->Data.Mb1Data),
    "MM MB1 record payload too small"
    );

  if (Write) {
    Payload->Command = NVIDIA_MM_MB1_RECORD_WRITE_CMD;
    CopyMem (Payload->Data, &EarlyVariable->Data.Mb1Data, sizeof (EarlyVariable->Data.Mb1Data));
  } else {
    Payload->Command = NVIDIA_MM_MB1_RECORD_READ_CMD;
  }

  Status = mMmCommunicate2->Communicate (
                              mMmCommunicate2,
                              mMmCommunicationBuffer,
                              mMmCommunicationBuffer,
                              &MmBufferSize
                              );
  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "%a: Failed to dispatch Mb1 MM command %r \r\n", __FUNCTION__, Status));
    return Status;
  }

  if (EFI_ERROR (Payload->Status)) {
    DEBUG ((DEBUG_ERROR, "%a: Error in Mb1 MM command %r \r\n", __FUNCTION__, Payload->Status));
    return Payload->Status;
  }

  if (!Write) {
    CopyMem (&EarlyVariable->Data.Mb1Data, Payload->Data, sizeof (EarlyVariable->Data.Mb1Data));
  }

  return Status;
}

// Read a single variable, set if undefined
EFI_STATUS
EFIAPI
GetMb1Variable (
  CHAR16  *VariableName,
  VOID    *VariableData,
  UINTN   VariableSize,
  UINT32  VariableAttributes
  )
{
  EFI_STATUS  Status;
  UINTN       ReadVariableSize;
  UINT32      Attributes;

  ReadVariableSize = 0;
  Status           = gRT->GetVariable (VariableName, &gNVIDIAPublicVariableGuid, &Attributes, &ReadVariableSize, NULL);
  if ((Status == EFI_NOT_FOUND) ||
      ((Status == EFI_BUFFER_TOO_SMALL) &&
       ((ReadVariableSize != VariableSize) ||
        (Attributes != VariableAttributes))))
  {
    if (Status != EFI_NOT_FOUND) {
      // Delete the variable
      gRT->SetVariable (VariableName, &gNVIDIAPublicVariableGuid, Attributes, 0, NULL);
    }

    Attributes = VariableAttributes;
    Status     = gRT->SetVariable (VariableName, &gNVIDIAPublicVariableGuid, Attributes, VariableSize, VariableData);
    return Status;
  } else if (Status != EFI_BUFFER_TOO_SMALL) {
    DEBUG ((DEBUG_ERROR, "%a: Unexpected return value - %r when getting variable\r\n", __FUNCTION__, Status));
    return Status;
  }

  ReadVariableSize = VariableSize;
  Status           = gRT->GetVariable (VariableName, &gNVIDIAPublicVariableGuid, &Attributes, &ReadVariableSize, VariableData);
  return Status;
}

// Sync the structure based on the EFI Variables
EFI_STATUS
EFIAPI
ReadMb1Variables (
  TEGRABL_EARLY_BOOT_VARIABLES  *EarlyVariable
  )
{
  EFI_STATUS  Status;
  CHAR16      VariableName[(MAX_VARIABLE_NAME/sizeof (CHAR16))];
  UINTN       Index;
  UINTN       Index2;
  UINT8       UphyConfig;

  Status = GetMb1Variable (
             L"Grace.MB1.FeatureData",
             (VOID *)&(EarlyVariable->Data.Mb1Data.FeatureData),
             sizeof (EarlyVariable->Data.Mb1Data.FeatureData),
             OS_CONFIG_VAR_ATTRIBUTES
             );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  Status = GetMb1Variable (
             L"Grace.MB1.HvRsvdMemSize",
             (VOID *)&(EarlyVariable->Data.Mb1Data.HvRsvdMemSize),
             sizeof (EarlyVariable->Data.Mb1Data.HvRsvdMemSize),
             OS_CONFIG_VAR_ATTRIBUTES
             );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  Status = GetMb1Variable (
             L"Grace.MB1.UefiDebugLevel",
             (VOID *)&(EarlyVariable->Data.Mb1Data.UefiDebugLevel),
             sizeof (EarlyVariable->Data.Mb1Data.UefiDebugLevel),
             OS_CONFIG_VAR_ATTRIBUTES
             );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  for (Index = 0; Index < TEGRABL_SOC_MAX_SOCKETS; Index++) {
    if (!mHiiControlSettings.SocketEnabled[Index]) {
      continue;
    }

    for (Index2 = 0; Index2 < TEGRABL_MAX_UPHY_PER_SOCKET; Index2++) {
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.MB1.UphyConfig.%x.%x", Index, Index2);
      UphyConfig = EarlyVariable->Data.Mb1Data.UphyConfig.UphyConfig[Index][Index2];
      Status     = GetMb1Variable (
                     VariableName,
                     (VOID *)&UphyConfig,
                     sizeof (UINT8),
                     OS_CONFIG_VAR_ATTRIBUTES
                     );
      if (EFI_ERROR (Status)) {
        return Status;
      }

      //
      // UPHY2 and UPHY3 can be configured as PCIE or NVLINK. Honor the current
      // setting and avoid changing from NVLINK to PCIE and vice versa.
      //
      if ((Index2 == 2) || (Index2 == 3)) {
        if ((UphyConfig > 4) ||
            ((EarlyVariable->Data.Mb1Data.UphyConfig.UphyConfig[Index][Index2] < 3) && (UphyConfig >= 3)) ||
            ((EarlyVariable->Data.Mb1Data.UphyConfig.UphyConfig[Index][Index2] > 2) && (UphyConfig <= 2)))
        {
          DEBUG ((
            DEBUG_WARN,
            "%a: Cannot change UPHY%u from %u to %u\n",
            __FUNCTION__,
            Index2,
            EarlyVariable->Data.Mb1Data.UphyConfig.UphyConfig[Index][Index2],
            UphyConfig
            ));
          continue;
        }
      }

      EarlyVariable->Data.Mb1Data.UphyConfig.UphyConfig[Index][Index2] = UphyConfig;
    }
  }

  for (Index = 0; Index < TEGRABL_SOC_MAX_SOCKETS; Index++) {
    if (!mHiiControlSettings.SocketEnabled[Index]) {
      continue;
    }

    for (Index2 = 0; Index2 < TEGRABL_MAX_PCIE_PER_SOCKET; Index2++) {
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.MB1.PcieConfig.%x.%x", Index, Index2);
      Status = GetMb1Variable (
                 VariableName,
                 (VOID *)&(EarlyVariable->Data.Mb1Data.PcieConfig[Index][Index2]),
                 sizeof (TEGRABL_MB1BCT_PCIE_CONFIG),
                 OS_CONFIG_VAR_ATTRIBUTES
                 );
      if (EFI_ERROR (Status)) {
        return Status;
      }
    }
  }

  return EFI_SUCCESS;
}

// Update the UEFI variables based on MB1 data
EFI_STATUS
EFIAPI
WriteMb1Variables (
  TEGRABL_EARLY_BOOT_VARIABLES  *NewVariable,
  TEGRABL_EARLY_BOOT_VARIABLES  *CurrentVariable,
  BOOLEAN                       ForceUpdate
  )
{
  EFI_STATUS  Status;
  CHAR16      VariableName[(MAX_VARIABLE_NAME/sizeof (CHAR16))];
  UINTN       Index;
  UINTN       Index2;
  VOID        *SrcPtr;
  VOID        *DestPtr;
  UINTN       Size;
  UINT32      Attributes;

  Attributes = UEFI_CONFIG_VAR_ATTRIBUTES;

  SrcPtr  = (VOID *)&(NewVariable->Data.Mb1Data.Header.MajorVersion);
  DestPtr = (VOID *)&(CurrentVariable->Data.Mb1Data.Header.MajorVersion);
  Size    = sizeof (NewVariable->Data.Mb1Data.Header.MajorVersion);
  Status  = gRT->SetVariable (
                   L"Grace.MB1.MajorVersion",
                   &gNVIDIAPublicVariableGuid,
                   Attributes,
                   Size,
                   SrcPtr
                   );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  CopyMem (DestPtr, SrcPtr, Size);

  SrcPtr  = (VOID *)&(NewVariable->Data.Mb1Data.Header.MinorVersion);
  DestPtr = (VOID *)&(CurrentVariable->Data.Mb1Data.Header.MinorVersion);
  Size    = sizeof (NewVariable->Data.Mb1Data.Header.MinorVersion);
  Status  = gRT->SetVariable (
                   L"Grace.MB1.MinorVersion",
                   &gNVIDIAPublicVariableGuid,
                   Attributes,
                   Size,
                   SrcPtr
                   );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  CopyMem (DestPtr, SrcPtr, Size);

  Attributes = OS_CONFIG_VAR_ATTRIBUTES;

  SrcPtr  = (VOID *)&(NewVariable->Data.Mb1Data.FeatureData);
  DestPtr = (VOID *)&(CurrentVariable->Data.Mb1Data.FeatureData);
  Size    = sizeof (NewVariable->Data.Mb1Data.FeatureData);
  if ((ForceUpdate) ||
      (CompareMem (SrcPtr, DestPtr, Size) != 0))
  {
    Status = gRT->SetVariable (
                    L"Grace.MB1.FeatureData",
                    &gNVIDIAPublicVariableGuid,
                    Attributes,
                    Size,
                    SrcPtr
                    );
    if (EFI_ERROR (Status)) {
      return Status;
    }

    CopyMem (DestPtr, SrcPtr, Size);
  }

  SrcPtr  = (VOID *)&(NewVariable->Data.Mb1Data.HvRsvdMemSize);
  DestPtr = (VOID *)&(CurrentVariable->Data.Mb1Data.HvRsvdMemSize);
  Size    = sizeof (NewVariable->Data.Mb1Data.HvRsvdMemSize);
  if ((ForceUpdate) ||
      (CompareMem (SrcPtr, DestPtr, Size) != 0))
  {
    Status = gRT->SetVariable (
                    L"Grace.MB1.HvRsvdMemSize",
                    &gNVIDIAPublicVariableGuid,
                    Attributes,
                    Size,
                    SrcPtr
                    );
    if (EFI_ERROR (Status)) {
      return Status;
    }

    CopyMem (DestPtr, SrcPtr, Size);
  }

  SrcPtr  = (VOID *)&(NewVariable->Data.Mb1Data.UefiDebugLevel);
  DestPtr = (VOID *)&(CurrentVariable->Data.Mb1Data.UefiDebugLevel);
  Size    = sizeof (NewVariable->Data.Mb1Data.UefiDebugLevel);
  if ((ForceUpdate) ||
      (CompareMem (SrcPtr, DestPtr, Size) != 0))
  {
    Status = gRT->SetVariable (
                    L"Grace.MB1.UefiDebugLevel",
                    &gNVIDIAPublicVariableGuid,
                    Attributes,
                    Size,
                    SrcPtr
                    );
    if (EFI_ERROR (Status)) {
      return Status;
    }

    CopyMem (DestPtr, SrcPtr, Size);
  }

  for (Index = 0; Index < TEGRABL_SOC_MAX_SOCKETS; Index++) {
    if (!mHiiControlSettings.SocketEnabled[Index]) {
      continue;
    }

    for (Index2 = 0; Index2 < TEGRABL_MAX_UPHY_PER_SOCKET; Index2++) {
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.MB1.UphyConfig.%x.%x", Index, Index2);
      SrcPtr  = (VOID *)&(NewVariable->Data.Mb1Data.UphyConfig.UphyConfig[Index][Index2]);
      DestPtr = (VOID *)&(CurrentVariable->Data.Mb1Data.UphyConfig.UphyConfig[Index][Index2]);
      Size    = sizeof (NewVariable->Data.Mb1Data.UphyConfig.UphyConfig[Index][Index2]);
      if ((ForceUpdate) ||
          (CompareMem (SrcPtr, DestPtr, Size) != 0))
      {
        Status = gRT->SetVariable (
                        VariableName,
                        &gNVIDIAPublicVariableGuid,
                        Attributes,
                        Size,
                        SrcPtr
                        );
        if (EFI_ERROR (Status)) {
          return Status;
        }

        CopyMem (DestPtr, SrcPtr, Size);
      }
    }
  }

  for (Index = 0; Index < TEGRABL_SOC_MAX_SOCKETS; Index++) {
    if (!mHiiControlSettings.SocketEnabled[Index]) {
      continue;
    }

    for (Index2 = 0; Index2 < TEGRABL_MAX_PCIE_PER_SOCKET; Index2++) {
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.MB1.PcieConfig.%x.%x", Index, Index2);
      SrcPtr  = (VOID *)&(NewVariable->Data.Mb1Data.PcieConfig[Index][Index2]);
      DestPtr = (VOID *)&(CurrentVariable->Data.Mb1Data.PcieConfig[Index][Index2]);
      Size    = sizeof (NewVariable->Data.Mb1Data.PcieConfig[Index][Index2]);
      if ((ForceUpdate) ||
          (CompareMem (SrcPtr, DestPtr, Size) != 0))
      {
        Status = gRT->SetVariable (
                        VariableName,
                        &gNVIDIAPublicVariableGuid,
                        Attributes,
                        Size,
                        SrcPtr
                        );
        if (EFI_ERROR (Status)) {
          return Status;
        }

        CopyMem (DestPtr, SrcPtr, Size);
      }
    }
  }

  return EFI_SUCCESS;
}

/**
  Sets and locks NV variable
**/
STATIC
EFI_STATUS
WriteAndLockPublicVariables (
  EDKII_VARIABLE_POLICY_PROTOCOL  *PolicyProtocol,
  VOID                            *VariableData,
  UINTN                           VariableSize,
  CHAR16                          *VariableName
  )
{
  EFI_STATUS  Status;
  UINT32      Attributes;

  Attributes = EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS;
  Status     = gRT->SetVariable (
                      VariableName,
                      &gNVIDIAPublicVariableGuid,
                      Attributes,
                      VariableSize,
                      VariableData
                      );
  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "Failed to set variable %s\r\n", VariableName));
    return Status;
  }

  Status = RegisterBasicVariablePolicy (
             PolicyProtocol,
             &gNVIDIAPublicVariableGuid,
             VariableName,
             0,
             0,
             0,
             0,
             VARIABLE_POLICY_TYPE_LOCK_NOW
             );
  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "Failed to register lock policy: %s-%r\r\n", VariableName, Status));
    return Status;
  }

  return EFI_SUCCESS;
}

/**
  Exposes the floorsweeping registers as volatile variables
**/
STATIC
VOID
WriteFloorsweepingVariables (
  VOID
  )
{
  EFI_STATUS                      Status;
  EDKII_VARIABLE_POLICY_PROTOCOL  *PolicyProtocol;
  UINT32                          VariableData[3];
  CHAR16                          VariableName[(MAX_VARIABLE_NAME/sizeof (CHAR16))];
  UINTN                           VariableSize;
  UINTN                           Socket;
  UINT32                          ExposeVariableControl;

  ExposeVariableControl = PcdGet32 (PcdFloorsweepingRuntimeVariables);

  Status = gBS->LocateProtocol (
                  &gEdkiiVariablePolicyProtocolGuid,
                  NULL,
                  (VOID **)&PolicyProtocol
                  );
  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "Failed to locate policy protocol\r\n"));
    return;
  }

  for (Socket = 0; Socket < MAX_SOCKETS; Socket++) {
    if (!mHiiControlSettings.SocketEnabled[Socket]) {
      continue;
    }

    if ((ExposeVariableControl & EXPOSE_PCIE_FLOORSWEEPING_VARIABLE) != 0) {
      VariableData[0]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + TH500_PCIE_FLOORSWEEPING_DISABLE_OFFSET);
      VariableData[0] &= ~TH500_PCIE_FLOORSWEEPING_DISABLE_MASK;
      VariableSize     = 2;
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.PCIeDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_NVML_FLOORSWEEPING_VARIABLE) != 0) {
      VariableData[0]   = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + NVLM_DISABLE_OFFSET);
      VariableData[0]  &= ~NVLM_DISABLE_MASK;
      VariableData[0] >>= NVLM_DISABLE_SHIFT;
      VariableSize      = 1;
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.NvlmDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_C2C_FLOORSWEEPING_VARIABLE) != 0) {
      VariableData[0]   = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + C2C_DISABLE_OFFSET);
      VariableData[0]  &= ~C2C_DISABLE_MASK;
      VariableData[0] >>= C2C_DISABLE_SHIFT;
      VariableSize      = 1;
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.C2CDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_HALF_CHIP_DISABLED_VARIABLE) != 0) {
      VariableData[0]   = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + HALF_CHIP_DISABLE_OFFSET);
      VariableData[0]  &= ~HALF_CHIP_DISABLE_MASK;
      VariableData[0] >>= HALF_CHIP_DISABLE_SHIFT;
      VariableSize      = 1;
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.HalfChipDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_MCF_CHANNEL_DISABLED_VARIABLE) != 0) {
      VariableData[0]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + MCF_CHANNEL_DISABLE_OFFSET);
      VariableData[0] &= ~MCF_CHANNEL_DISABLE_MASK;
      VariableSize     = sizeof (UINT32);
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.McfChannelDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_UPHY_LANE_OWNERSHIP_VARAIBLE) != 0) {
      VariableData[0]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + UPHY_LANE_OWNERSHIP_OFFSET);
      VariableData[0] &= ~UPHY_LANE_OWNERSHIP_MASK;
      VariableSize     = sizeof (UINT32);
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.UphyLaneOwnership.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_CCPLEX_CORE_DISABLED_VARIABLE) != 0) {
      VariableData[0]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + TH500_CPU_FLOORSWEEPING_DISABLE_OFFSET_0);
      VariableData[0] &= ~TH500_CPU_FLOORSWEEPING_DISABLE_MASK_0;
      VariableData[1]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + TH500_CPU_FLOORSWEEPING_DISABLE_OFFSET_1);
      VariableData[1] &= ~TH500_CPU_FLOORSWEEPING_DISABLE_MASK_1;
      VariableData[2]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + TH500_CPU_FLOORSWEEPING_DISABLE_OFFSET_2);
      VariableData[2] &= ~TH500_CPU_FLOORSWEEPING_DISABLE_MASK_2;
      VariableSize     = 3*sizeof (UINT32);
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.CcplexCoreDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_CCPLEX_MCF_BRIDGE_DISABLED_VARIABLE) != 0) {
      VariableData[0]   = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + CCPLEX_MCF_BR_DISABLE_OFFSET);
      VariableData[0]  &= ~CCPLEX_MCF_BR_DISABLE_MASK;
      VariableData[0] >>= CCPLEX_MCF_BR_DISABLE_SHIFT;
      VariableSize      = sizeof (UINT32);
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.CcplexMcfBridgeDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_CCPLEX_SOC_BRIDGE_DISABLED_VARIABLE) != 0) {
      VariableData[0]   = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + CCPLEX_SOC_BR_DISABLE_OFFSET);
      VariableData[0]  &= ~CCPLEX_SOC_BR_DISABLE_MASK;
      VariableData[0] >>= CCPLEX_SOC_BR_DISABLE_SHIFT;
      VariableSize      = 1;
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.CcplexSocBridgeDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_CCPLEX_CSN_DISABLED_VARIABLE) != 0) {
      VariableData[0]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + CCPLEX_CSN_DISABLE_OFFSET_0);
      VariableData[0] &= ~CCPLEX_CSN_DISABLE_MASK_0;
      VariableData[1]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + CCPLEX_CSN_DISABLE_OFFSET_1);
      VariableData[1] &= ~CCPLEX_CSN_DISABLE_MASK_1;
      VariableSize     = 2*sizeof (UINT32);
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.CcplexCsnDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }

    if ((ExposeVariableControl & EXPOSE_SCF_CACHE_DISABLED_VARIABLE) != 0) {
      VariableData[0]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + TH500_SCF_CACHE_FLOORSWEEPING_DISABLE_OFFSET_0);
      VariableData[0] &= ~TH500_SCF_CACHE_FLOORSWEEPING_DISABLE_MASK_0;
      VariableData[1]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + TH500_SCF_CACHE_FLOORSWEEPING_DISABLE_OFFSET_1);
      VariableData[1] &= ~TH500_SCF_CACHE_FLOORSWEEPING_DISABLE_MASK_1;
      VariableData[2]  = MmioRead32 (TH500SocketScratchBaseAddr[Socket] + TH500_SCF_CACHE_FLOORSWEEPING_DISABLE_OFFSET_2);
      VariableData[2] &= ~TH500_SCF_CACHE_FLOORSWEEPING_DISABLE_MASK_2;
      VariableSize     = 3*sizeof (UINT32);
      UnicodeSPrint (VariableName, sizeof (VariableName), L"Grace.Status.ScfCacheDisabled.%x", Socket);
      WriteAndLockPublicVariables (PolicyProtocol, VariableData, VariableSize, VariableName);
    }
  }
}

/**
  Syncs settings betweem Control settings and MB1 Config structure

**/
VOID
EFIAPI
SyncHiiSettings (
  IN BOOLEAN  Read
  )
{
  UINTN                         Index;
  VOID                          *Hob;
  TEGRA_PLATFORM_RESOURCE_INFO  *PlatformResourceInfo = NULL;
  UINTN                         AvailableSockets;
  UINTN                         SymmetricalActiveCoresPerSocket;
  UINTN                         OverflowActiveCoresPerSocket;
  UINTN                         TotalEnabledCores;

  Hob = GetFirstGuidHob (&gNVIDIAPlatformResourceDataGuid);
  if ((Hob != NULL) &&
      (GET_GUID_HOB_DATA_SIZE (Hob) == sizeof (TEGRA_PLATFORM_RESOURCE_INFO)))
  {
    PlatformResourceInfo = (TEGRA_PLATFORM_RESOURCE_INFO *)GET_GUID_HOB_DATA (Hob);
  } else {
    DEBUG ((DEBUG_ERROR, "Failed to get platform resource data\n"));
    ASSERT (FALSE);
  }

  AvailableSockets                = 0;
  SymmetricalActiveCoresPerSocket = 0;
  OverflowActiveCoresPerSocket    = 0;
  for (Index = 0; Index < MAX_SOCKETS; Index++) {
    if (mHiiControlSettings.SocketEnabled[Index]) {
      AvailableSockets++;
    }
  }

  if (Read) {
    mHiiControlSettings.EgmEnabled           = mMb1Config.Data.Mb1Data.FeatureData.EgmEnable;
    mHiiControlSettings.EgmHvSizeMb          = mMb1Config.Data.Mb1Data.HvRsvdMemSize;
    mHiiControlSettings.HvMinEgmSize         = mMb1Config.Data.Mb1Data.HvMinEgmSize;
    mHiiControlSettings.HvVirtUefiSize       = mMb1Config.Data.Mb1Data.HvVirtUefiSize;
    mHiiControlSettings.SpreadSpectrumEnable = mMb1Config.Data.Mb1Data.FeatureData.SpreadSpecEnable;
    mHiiControlSettings.ModsSpEnable         = mMb1Config.Data.Mb1Data.FeatureData.ModsSpEnable;
    mHiiControlSettings.TpmEnable            = mMb1Config.Data.Mb1Data.FeatureData.TpmEnable;
    mHiiControlSettings.GpuSmmuBypassEnable  = mMb1Config.Data.Mb1Data.FeatureData.GpuSmmuBypassEnable;

    if (mMb1Config.Data.Mb1Data.FeatureData.UartBaudRate >= UART_BAUD_RATE_MAX) {
      mHiiControlSettings.UartBaudRate = UART_BAUD_RATE_115200;
    } else {
      mHiiControlSettings.UartBaudRate = mMb1Config.Data.Mb1Data.FeatureData.UartBaudRate;
    }

    mHiiControlSettings.EInjEnable            = mMb1Config.Data.Mb1Data.FeatureData.EInjEnable;
    mHiiControlSettings.DisableChannelSparing = mMb1Config.Data.Mb1Data.FeatureData.DisableChannelSparing;
    mHiiControlSettings.MaxAllowedNumSpares   = mMb1Config.Data.Mb1Data.FeatureData.MaxAllowedNumSpares;
    mHiiControlSettings.PerfVersion           = mMb1Config.Data.Mb1Data.PerfVersion;
    mHiiControlSettings.UefiDebugLevel        = mMb1Config.Data.Mb1Data.UefiDebugLevel;
    if (mMb1Config.Data.Mb1Data.FeatureData.EccAlgorithm > ECC_ALGORITHM_RS) {
      mHiiControlSettings.EccAlgorithm = ECC_ALGORITHM_HSIAO;
    } else {
      mHiiControlSettings.EccAlgorithm = mMb1Config.Data.Mb1Data.FeatureData.EccAlgorithm;
    }

    mHiiControlSettings.ActiveCores = 0;
    for (Index = 0; Index < MAX_SOCKETS; Index++) {
      mHiiControlSettings.ActiveCores += mMb1Config.Data.Mb1Data.ActiveCores[Index];
    }

    for (Index = 0; Index < TEGRABL_MAX_UPHY_PER_SOCKET; Index++) {
      mHiiControlSettings.UphySetting0[Index] = mMb1Config.Data.Mb1Data.UphyConfig.UphyConfig[0][Index];
      mHiiControlSettings.UphySetting1[Index] = mMb1Config.Data.Mb1Data.UphyConfig.UphyConfig[1][Index];
      mHiiControlSettings.UphySetting2[Index] = mMb1Config.Data.Mb1Data.UphyConfig.UphyConfig[2][Index];
      mHiiControlSettings.UphySetting3[Index] = mMb1Config.Data.Mb1Data.UphyConfig.UphyConfig[3][Index];
    }

    for (Index = 0; Index < TEGRABL_MAX_PCIE_PER_SOCKET; Index++) {
      mHiiControlSettings.MaxSpeed0[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].MaxSpeed;
      mHiiControlSettings.MaxWidth0[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].MaxWidth;
      mHiiControlSettings.SlotType0[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].SlotType;
      mHiiControlSettings.SlotNum0[Index]                 = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].SlotNum;
      mHiiControlSettings.AdvertiseAspmL1_0[Index]        = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertiseAspmL1;
      mHiiControlSettings.AdvertiseAspmL1_1_0[Index]      = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertiseAspmL1_1;
      mHiiControlSettings.AdvertiseAspmL1_2_0[Index]      = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertiseAspmL1_2;
      mHiiControlSettings.AdvertisePciPmL1_2_0[Index]     = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertisePciPmL1_2;
      mHiiControlSettings.SupportsClkReq0[Index]          = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].SupportsClkReq;
      mHiiControlSettings.DisableDLFE0[Index]             = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].DisableDLFE;
      mHiiControlSettings.EnableECRC_0[Index]             = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].EnableECRC;
      mHiiControlSettings.DisableDPCAtRP_0[Index]         = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].DisableDPCAtRP;
      mHiiControlSettings.MaskUnsupportedRequest_0[Index] = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].MaskUnsupportedRequest;
      mHiiControlSettings.MaskCompleterAbort_0[Index]     = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].MaskCompleterAbort;
      mHiiControlSettings.SupportsPRSNT_0[Index]          = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].SupportsPRSNT;
      mHiiControlSettings.AdvertiseACS_0[Index]           = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertiseACS;
      mHiiControlSettings.OsNativeAER_0[Index]            = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].OsNativeAER;
      mHiiControlSettings.DisableL23AtWarmReset_0[Index]  = mMb1Config.Data.Mb1Data.PcieConfig[0][Index].DisableL23AtWarmReset;
      mHiiControlSettings.MaxSpeed1[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].MaxSpeed;
      mHiiControlSettings.MaxWidth1[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].MaxWidth;
      mHiiControlSettings.SlotType1[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].SlotType;
      mHiiControlSettings.SlotNum1[Index]                 = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].SlotNum;
      mHiiControlSettings.AdvertiseAspmL1_1[Index]        = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertiseAspmL1;
      mHiiControlSettings.AdvertiseAspmL1_1_1[Index]      = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertiseAspmL1_1;
      mHiiControlSettings.AdvertiseAspmL1_2_1[Index]      = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertiseAspmL1_2;
      mHiiControlSettings.AdvertisePciPmL1_2_1[Index]     = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertisePciPmL1_2;
      mHiiControlSettings.SupportsClkReq1[Index]          = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].SupportsClkReq;
      mHiiControlSettings.DisableDLFE1[Index]             = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].DisableDLFE;
      mHiiControlSettings.EnableECRC_1[Index]             = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].EnableECRC;
      mHiiControlSettings.DisableDPCAtRP_1[Index]         = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].DisableDPCAtRP;
      mHiiControlSettings.MaskUnsupportedRequest_1[Index] = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].MaskUnsupportedRequest;
      mHiiControlSettings.MaskCompleterAbort_1[Index]     = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].MaskCompleterAbort;
      mHiiControlSettings.SupportsPRSNT_1[Index]          = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].SupportsPRSNT;
      mHiiControlSettings.AdvertiseACS_1[Index]           = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertiseACS;
      mHiiControlSettings.OsNativeAER_1[Index]            = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].OsNativeAER;
      mHiiControlSettings.DisableL23AtWarmReset_1[Index]  = mMb1Config.Data.Mb1Data.PcieConfig[1][Index].DisableL23AtWarmReset;
      mHiiControlSettings.MaxSpeed2[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].MaxSpeed;
      mHiiControlSettings.MaxWidth2[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].MaxWidth;
      mHiiControlSettings.SlotType2[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].SlotType;
      mHiiControlSettings.SlotNum2[Index]                 = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].SlotNum;
      mHiiControlSettings.AdvertiseAspmL1_2[Index]        = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertiseAspmL1;
      mHiiControlSettings.AdvertiseAspmL1_1_2[Index]      = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertiseAspmL1_1;
      mHiiControlSettings.AdvertiseAspmL1_2_2[Index]      = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertiseAspmL1_2;
      mHiiControlSettings.AdvertisePciPmL1_2_2[Index]     = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertisePciPmL1_2;
      mHiiControlSettings.SupportsClkReq2[Index]          = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].SupportsClkReq;
      mHiiControlSettings.DisableDLFE2[Index]             = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].DisableDLFE;
      mHiiControlSettings.EnableECRC_2[Index]             = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].EnableECRC;
      mHiiControlSettings.DisableDPCAtRP_2[Index]         = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].DisableDPCAtRP;
      mHiiControlSettings.MaskUnsupportedRequest_2[Index] = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].MaskUnsupportedRequest;
      mHiiControlSettings.MaskCompleterAbort_2[Index]     = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].MaskCompleterAbort;
      mHiiControlSettings.SupportsPRSNT_2[Index]          = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].SupportsPRSNT;
      mHiiControlSettings.AdvertiseACS_2[Index]           = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertiseACS;
      mHiiControlSettings.OsNativeAER_2[Index]            = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].OsNativeAER;
      mHiiControlSettings.DisableL23AtWarmReset_2[Index]  = mMb1Config.Data.Mb1Data.PcieConfig[2][Index].DisableL23AtWarmReset;
      mHiiControlSettings.MaxSpeed3[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].MaxSpeed;
      mHiiControlSettings.MaxWidth3[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].MaxWidth;
      mHiiControlSettings.SlotType3[Index]                = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].SlotType;
      mHiiControlSettings.SlotNum3[Index]                 = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].SlotNum;
      mHiiControlSettings.AdvertiseAspmL1_3[Index]        = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertiseAspmL1;
      mHiiControlSettings.AdvertiseAspmL1_1_3[Index]      = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertiseAspmL1_1;
      mHiiControlSettings.AdvertiseAspmL1_2_3[Index]      = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertiseAspmL1_2;
      mHiiControlSettings.AdvertisePciPmL1_2_3[Index]     = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertisePciPmL1_2;
      mHiiControlSettings.SupportsClkReq3[Index]          = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].SupportsClkReq;
      mHiiControlSettings.DisableDLFE3[Index]             = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].DisableDLFE;
      mHiiControlSettings.EnableECRC_3[Index]             = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].EnableECRC;

      mHiiControlSettings.DisableOptionRom0[Index]        = (mOpRomDisMask & (1ULL << PCIE_SEG (0, Index))) != 0ULL;
      mHiiControlSettings.DisableOptionRom1[Index]        = (mOpRomDisMask & (1ULL << PCIE_SEG (1, Index))) != 0ULL;
      mHiiControlSettings.DisableOptionRom2[Index]        = (mOpRomDisMask & (1ULL << PCIE_SEG (2, Index))) != 0ULL;
      mHiiControlSettings.DisableOptionRom3[Index]        = (mOpRomDisMask & (1ULL << PCIE_SEG (3, Index))) != 0ULL;
      mHiiControlSettings.DisableDPCAtRP_3[Index]         = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].DisableDPCAtRP;
      mHiiControlSettings.MaskUnsupportedRequest_3[Index] = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].MaskUnsupportedRequest;
      mHiiControlSettings.MaskCompleterAbort_3[Index]     = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].MaskCompleterAbort;
      mHiiControlSettings.SupportsPRSNT_3[Index]          = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].SupportsPRSNT;
      mHiiControlSettings.AdvertiseACS_3[Index]           = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertiseACS;
      mHiiControlSettings.MaxPayloadSize0[Index]          = (mMaxPayloadSize[0] >> (Index * 3)) & (7ULL);
      mHiiControlSettings.MaxPayloadSize1[Index]          = (mMaxPayloadSize[1] >> (Index * 3)) & (7ULL);
      mHiiControlSettings.MaxPayloadSize2[Index]          = (mMaxPayloadSize[2] >> (Index * 3)) & (7ULL);
      mHiiControlSettings.MaxPayloadSize3[Index]          = (mMaxPayloadSize[3] >> (Index * 3)) & (7ULL);

      mHiiControlSettings.Extended10bitTagEnable0[Index] = (mExt10bitTagReqEnable & (1ULL << PCIE_SEG (0, Index))) != 0ULL;
      mHiiControlSettings.Extended10bitTagEnable1[Index] = (mExt10bitTagReqEnable & (1ULL << PCIE_SEG (1, Index))) != 0ULL;
      mHiiControlSettings.Extended10bitTagEnable2[Index] = (mExt10bitTagReqEnable & (1ULL << PCIE_SEG (2, Index))) != 0ULL;
      mHiiControlSettings.Extended10bitTagEnable3[Index] = (mExt10bitTagReqEnable & (1ULL << PCIE_SEG (3, Index))) != 0ULL;

      mHiiControlSettings.OsNativeAER_3[Index]           = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].OsNativeAER;
      mHiiControlSettings.DisableL23AtWarmReset_3[Index] = mMb1Config.Data.Mb1Data.PcieConfig[3][Index].DisableL23AtWarmReset;
    }

    // MPAM non architected part ids 40-44 per socket
    for (Index = MPAM_PARTID_OFFSET; Index < (MPAM_PARTID_OFFSET + TEGRABL_MAX_MPAM_PARTID); Index++) {
      mHiiControlSettings.CporWayMask[Index] = mMb1Config.Data.Mb1Data.MpamConfig[Index-MPAM_PARTID_OFFSET].CporWayMask;
      mHiiControlSettings.MaxBw[Index]       = mMb1Config.Data.Mb1Data.MpamConfig[Index-MPAM_PARTID_OFFSET].MaxBw;
      mHiiControlSettings.MinBw[Index]       = mMb1Config.Data.Mb1Data.MpamConfig[Index-MPAM_PARTID_OFFSET].MinBw;
    }
  } else {
    mMb1Config.Data.Mb1Data.FeatureData.EgmEnable             = mHiiControlSettings.EgmEnabled;
    mMb1Config.Data.Mb1Data.HvRsvdMemSize                     = mHiiControlSettings.EgmHvSizeMb;
    mMb1Config.Data.Mb1Data.HvMinEgmSize                      = mHiiControlSettings.HvMinEgmSize;
    mMb1Config.Data.Mb1Data.HvVirtUefiSize                    = mHiiControlSettings.HvVirtUefiSize;
    mMb1Config.Data.Mb1Data.FeatureData.SpreadSpecEnable      = mHiiControlSettings.SpreadSpectrumEnable;
    mMb1Config.Data.Mb1Data.FeatureData.ModsSpEnable          = mHiiControlSettings.ModsSpEnable;
    mMb1Config.Data.Mb1Data.FeatureData.TpmEnable             = mHiiControlSettings.TpmEnable;
    mMb1Config.Data.Mb1Data.FeatureData.GpuSmmuBypassEnable   = mHiiControlSettings.GpuSmmuBypassEnable;
    mMb1Config.Data.Mb1Data.FeatureData.UartBaudRate          = mHiiControlSettings.UartBaudRate;
    mMb1Config.Data.Mb1Data.FeatureData.EInjEnable            = mHiiControlSettings.EInjEnable;
    mMb1Config.Data.Mb1Data.FeatureData.DisableChannelSparing = mHiiControlSettings.DisableChannelSparing;
    mMb1Config.Data.Mb1Data.FeatureData.EccAlgorithm          = mHiiControlSettings.EccAlgorithm;
    mMb1Config.Data.Mb1Data.FeatureData.MaxAllowedNumSpares   = mHiiControlSettings.MaxAllowedNumSpares;
    mMb1Config.Data.Mb1Data.PerfVersion                       = mHiiControlSettings.PerfVersion;
    mMb1Config.Data.Mb1Data.UefiDebugLevel                    = mHiiControlSettings.UefiDebugLevel;

    if (mHiiControlSettings.ActiveCores < AvailableSockets) {
      mHiiControlSettings.ActiveCores = 0;
    }

    TotalEnabledCores = GetTotalEnabledCores ();
    if (mHiiControlSettings.ActiveCores > TotalEnabledCores) {
      DEBUG ((DEBUG_ERROR, "%a: Max ActiveCores can't exceed %u", __func__, TotalEnabledCores));
      mHiiControlSettings.ActiveCores = TotalEnabledCores;
    }

    SymmetricalActiveCoresPerSocket = mHiiControlSettings.ActiveCores / AvailableSockets;
    OverflowActiveCoresPerSocket    = mHiiControlSettings.ActiveCores % AvailableSockets;
    for (Index = 0; Index < MAX_SOCKETS; Index++) {
      if (mHiiControlSettings.SocketEnabled[Index]) {
        mMb1Config.Data.Mb1Data.ActiveCores[Index] = SymmetricalActiveCoresPerSocket;
      }
    }

    for (Index = 0; Index < MAX_SOCKETS; Index++) {
      if (OverflowActiveCoresPerSocket == 0) {
        break;
      }

      if (mHiiControlSettings.SocketEnabled[Index]) {
        mMb1Config.Data.Mb1Data.ActiveCores[Index]++;
        OverflowActiveCoresPerSocket--;
      }
    }

    for (Index = 0; Index < TEGRABL_MAX_UPHY_PER_SOCKET; Index++) {
      mMb1Config.Data.Mb1Data.UphyConfig.UphyConfig[0][Index] = mHiiControlSettings.UphySetting0[Index];
      mMb1Config.Data.Mb1Data.UphyConfig.UphyConfig[1][Index] = mHiiControlSettings.UphySetting1[Index];
      mMb1Config.Data.Mb1Data.UphyConfig.UphyConfig[2][Index] = mHiiControlSettings.UphySetting2[Index];
      mMb1Config.Data.Mb1Data.UphyConfig.UphyConfig[3][Index] = mHiiControlSettings.UphySetting3[Index];
    }

    mOpRomDisMask         = 0ULL;
    mExt10bitTagReqEnable = 0ULL;
    ZeroMem (mMaxPayloadSize, sizeof (mMaxPayloadSize));
    for (Index = 0; Index < TEGRABL_MAX_PCIE_PER_SOCKET; Index++) {
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].MaxSpeed               = mHiiControlSettings.MaxSpeed0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].MaxWidth               = mHiiControlSettings.MaxWidth0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].SlotType               = mHiiControlSettings.SlotType0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].SlotNum                = mHiiControlSettings.SlotNum0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertiseAspmL1        = mHiiControlSettings.AdvertiseAspmL1_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertiseAspmL1_1      = mHiiControlSettings.AdvertiseAspmL1_1_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertiseAspmL1_2      = mHiiControlSettings.AdvertiseAspmL1_2_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertisePciPmL1_2     = mHiiControlSettings.AdvertisePciPmL1_2_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].SupportsClkReq         = mHiiControlSettings.SupportsClkReq0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].DisableDLFE            = mHiiControlSettings.DisableDLFE0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].EnableECRC             = mHiiControlSettings.EnableECRC_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].DisableDPCAtRP         = mHiiControlSettings.DisableDPCAtRP_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].MaskUnsupportedRequest = mHiiControlSettings.MaskUnsupportedRequest_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].MaskCompleterAbort     = mHiiControlSettings.MaskCompleterAbort_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].SupportsPRSNT          = mHiiControlSettings.SupportsPRSNT_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].AdvertiseACS           = mHiiControlSettings.AdvertiseACS_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].OsNativeAER            = mHiiControlSettings.OsNativeAER_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[0][Index].DisableL23AtWarmReset  = mHiiControlSettings.DisableL23AtWarmReset_0[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].MaxSpeed               = mHiiControlSettings.MaxSpeed1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].MaxWidth               = mHiiControlSettings.MaxWidth1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].SlotType               = mHiiControlSettings.SlotType1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].SlotNum                = mHiiControlSettings.SlotNum1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertiseAspmL1        = mHiiControlSettings.AdvertiseAspmL1_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertiseAspmL1_1      = mHiiControlSettings.AdvertiseAspmL1_1_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertiseAspmL1_2      = mHiiControlSettings.AdvertiseAspmL1_2_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertisePciPmL1_2     = mHiiControlSettings.AdvertisePciPmL1_2_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].SupportsClkReq         = mHiiControlSettings.SupportsClkReq1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].DisableDLFE            = mHiiControlSettings.DisableDLFE1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].EnableECRC             = mHiiControlSettings.EnableECRC_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].DisableDPCAtRP         = mHiiControlSettings.DisableDPCAtRP_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].MaskUnsupportedRequest = mHiiControlSettings.MaskUnsupportedRequest_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].MaskCompleterAbort     = mHiiControlSettings.MaskCompleterAbort_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].SupportsPRSNT          = mHiiControlSettings.SupportsPRSNT_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].AdvertiseACS           = mHiiControlSettings.AdvertiseACS_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].OsNativeAER            = mHiiControlSettings.OsNativeAER_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[1][Index].DisableL23AtWarmReset  = mHiiControlSettings.DisableL23AtWarmReset_1[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].MaxSpeed               = mHiiControlSettings.MaxSpeed2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].MaxWidth               = mHiiControlSettings.MaxWidth2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].SlotType               = mHiiControlSettings.SlotType2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].SlotNum                = mHiiControlSettings.SlotNum2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertiseAspmL1        = mHiiControlSettings.AdvertiseAspmL1_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertiseAspmL1_1      = mHiiControlSettings.AdvertiseAspmL1_1_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertiseAspmL1_2      = mHiiControlSettings.AdvertiseAspmL1_2_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertisePciPmL1_2     = mHiiControlSettings.AdvertisePciPmL1_2_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].SupportsClkReq         = mHiiControlSettings.SupportsClkReq2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].DisableDLFE            = mHiiControlSettings.DisableDLFE2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].EnableECRC             = mHiiControlSettings.EnableECRC_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].DisableDPCAtRP         = mHiiControlSettings.DisableDPCAtRP_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].MaskUnsupportedRequest = mHiiControlSettings.MaskUnsupportedRequest_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].MaskCompleterAbort     = mHiiControlSettings.MaskCompleterAbort_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].SupportsPRSNT          = mHiiControlSettings.SupportsPRSNT_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].AdvertiseACS           = mHiiControlSettings.AdvertiseACS_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].OsNativeAER            = mHiiControlSettings.OsNativeAER_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[2][Index].DisableL23AtWarmReset  = mHiiControlSettings.DisableL23AtWarmReset_2[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].MaxSpeed               = mHiiControlSettings.MaxSpeed3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].MaxWidth               = mHiiControlSettings.MaxWidth3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].SlotType               = mHiiControlSettings.SlotType3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].SlotNum                = mHiiControlSettings.SlotNum3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertiseAspmL1        = mHiiControlSettings.AdvertiseAspmL1_3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertiseAspmL1_1      = mHiiControlSettings.AdvertiseAspmL1_1_3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertiseAspmL1_2      = mHiiControlSettings.AdvertiseAspmL1_2_3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertisePciPmL1_2     = mHiiControlSettings.AdvertisePciPmL1_2_3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].SupportsClkReq         = mHiiControlSettings.SupportsClkReq3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].DisableDLFE            = mHiiControlSettings.DisableDLFE3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].EnableECRC             = mHiiControlSettings.EnableECRC_3[Index];

      mOpRomDisMask                                                      |= mHiiControlSettings.DisableOptionRom0[Index] ? (1ULL << PCIE_SEG (0, Index)) : 0ULL;
      mOpRomDisMask                                                      |= mHiiControlSettings.DisableOptionRom1[Index] ? (1ULL << PCIE_SEG (1, Index)) : 0ULL;
      mOpRomDisMask                                                      |= mHiiControlSettings.DisableOptionRom2[Index] ? (1ULL << PCIE_SEG (2, Index)) : 0ULL;
      mOpRomDisMask                                                      |= mHiiControlSettings.DisableOptionRom3[Index] ? (1ULL << PCIE_SEG (3, Index)) : 0ULL;
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].DisableDPCAtRP         = mHiiControlSettings.DisableDPCAtRP_3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].MaskUnsupportedRequest = mHiiControlSettings.MaskUnsupportedRequest_3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].MaskCompleterAbort     = mHiiControlSettings.MaskCompleterAbort_3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].SupportsPRSNT          = mHiiControlSettings.SupportsPRSNT_3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].AdvertiseACS           = mHiiControlSettings.AdvertiseACS_3[Index];
      mMaxPayloadSize[0]                                                 |= (mHiiControlSettings.MaxPayloadSize0[Index] & 7ULL) << (Index * 3);
      mMaxPayloadSize[1]                                                 |= (mHiiControlSettings.MaxPayloadSize1[Index] & 7ULL) << (Index * 3);
      mMaxPayloadSize[2]                                                 |= (mHiiControlSettings.MaxPayloadSize2[Index] & 7ULL) << (Index * 3);
      mMaxPayloadSize[3]                                                 |= (mHiiControlSettings.MaxPayloadSize3[Index] & 7ULL) << (Index * 3);
      mExt10bitTagReqEnable                                              |= mHiiControlSettings.Extended10bitTagEnable0[Index] ? (1ULL << PCIE_SEG (0, Index)) : 0ULL;
      mExt10bitTagReqEnable                                              |= mHiiControlSettings.Extended10bitTagEnable1[Index] ? (1ULL << PCIE_SEG (1, Index)) : 0ULL;
      mExt10bitTagReqEnable                                              |= mHiiControlSettings.Extended10bitTagEnable2[Index] ? (1ULL << PCIE_SEG (2, Index)) : 0ULL;
      mExt10bitTagReqEnable                                              |= mHiiControlSettings.Extended10bitTagEnable3[Index] ? (1ULL << PCIE_SEG (3, Index)) : 0ULL;
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].OsNativeAER            = mHiiControlSettings.OsNativeAER_3[Index];
      mMb1Config.Data.Mb1Data.PcieConfig[3][Index].DisableL23AtWarmReset  = mHiiControlSettings.DisableL23AtWarmReset_3[Index];
    }

    // MPAM non architected part ids 40-44 per socket
    for (Index = MPAM_PARTID_OFFSET; Index < (MPAM_PARTID_OFFSET + TEGRABL_MAX_MPAM_PARTID); Index++) {
      mMb1Config.Data.Mb1Data.MpamConfig[Index-MPAM_PARTID_OFFSET].CporWayMask =  mHiiControlSettings.CporWayMask[Index];

      // Check for incorrectness in entries from user
      if (mHiiControlSettings.MaxBw[Index] < mHiiControlSettings.MinBw[Index]) {
        DEBUG ((DEBUG_ERROR, "%a: Max les than Min fix it!!\r\n", __FUNCTION__));
        mHiiControlSettings.MaxBw[Index] = mHiiControlSettings.MinBw[Index];
      }

      mMb1Config.Data.Mb1Data.MpamConfig[Index-MPAM_PARTID_OFFSET].MaxBw = mHiiControlSettings.MaxBw[Index];
      mMb1Config.Data.Mb1Data.MpamConfig[Index-MPAM_PARTID_OFFSET].MinBw = mHiiControlSettings.MinBw[Index];
      mMb1Config.Data.Mb1Data.MpamConfig[Index-MPAM_PARTID_OFFSET].MaxBw = mHiiControlSettings.MaxBw[Index];
    }
  }
}

/**
  Initializes any variables to current or default settings

**/
VOID
EFIAPI
InitializeSettings (
  )
{
  EFI_STATUS                            Status;
  VOID                                  *AcpiBase;
  NVIDIA_SERVER_POWER_CONTROL_PROTOCOL  *ServerPwrCtl;
  NVIDIA_KERNEL_COMMAND_LINE            CmdLine;
  UINTN                                 KernelCmdLineLen;
  NVIDIA_PRODUCT_INFO                   ProductInfo;
  UINTN                                 ProductInfoLen;
  UINTN                                 BufferSize;
  UINTN                                 Index;
  CONST TEGRABL_EARLY_BOOT_VARIABLES    *TH500HobConfig;
  VOID                                  *HobPointer;
  BOOLEAN                               DiscardVariableOverrides;
  CHAR16                                ProductInfoVariableName[] = L"ProductInfo";
  BOOLEAN                               AcpiMode;
  VOID                                  *Table;

  AcpiMode = !EFI_ERROR (EfiGetSystemConfigurationTable (&gEfiAcpiTableGuid, &Table));

  // Initialize PCIe Form Settings
  PcdSet8S (PcdPcieResourceConfigNeeded, PcdGet8 (PcdPcieResourceConfigNeeded));
  PcdSet8S (PcdPcieEntryInAcpiConfigNeeded, PcdGet8 (PcdPcieEntryInAcpiConfigNeeded));
  PcdSet8S (PcdPcieEntryInAcpi, PcdGet8 (PcdPcieEntryInAcpi));
  if (PcdGet8 (PcdPcieResourceConfigNeeded) == 1) {
    Status = EfiGetSystemConfigurationTable (&gEfiAcpiTableGuid, &AcpiBase);
    if (EFI_ERROR (Status)) {
      PcdSet8S (PcdPcieResourceConfigNeeded, 0);
      PcdSet8S (PcdPcieEntryInAcpiConfigNeeded, 0);
    }
  }

  // Initialize Quick Boot Form Settings
  PcdSet8S (PcdQuickBootEnabled, PcdGet8 (PcdQuickBootEnabled));

  // Initialize New Device Hierarchy Form Settings
  PcdSet8S (PcdNewDeviceHierarchy, PcdGet8 (PcdNewDeviceHierarchy));

  // Initialize OS Chain A status Form Settings
  PcdSet32S (PcdOsChainStatusA, PcdGet32 (PcdOsChainStatusA));

  // Initialize OS Chain B status Form Settings
  PcdSet32S (PcdOsChainStatusB, PcdGet32 (PcdOsChainStatusB));

  // Initialize L4T boot mode Form Settings
  PcdSet32S (PcdL4TDefaultBootMode, PcdGet32 (PcdL4TDefaultBootMode));

  // Initialize the IPMI network boot mode Form Settings
  PcdSet8S (PcdIpmiNetworkBootMode, PcdGet8 (PcdIpmiNetworkBootMode));

  // Initialize Acpi Timer Form Settings
  PcdSet8S (PcdAcpiTimerEnabled, PcdGet8 (PcdAcpiTimerEnabled));

  // Initialize UEFI Shell Form Settings
  PcdSet8S (PcdUefiShellEnabled, PcdGet8 (PcdUefiShellEnabled));

  // Initialize dGPU DT EFIFB support form settings
  PcdSet8S (PcdDgpuDtEfifbSupport, PcdGet8 (PcdDgpuDtEfifbSupport));

  // Initialize Redfish Host Interface
  PcdSet8S (PcdRedfishHostInterface, PcdGet8 (PcdRedfishHostInterface));

  // Initialize Enabled PCIe NIC topology
  BufferSize = sizeof (NVIDIA_ENABLED_PCIE_NIC_TOPOLOGY);
  PcdSetPtrS (PcdEnabledPcieNicTopology, &BufferSize, PcdGetPtr (PcdEnabledPcieNicTopology));

  // Initialize Memory Test settings
  BufferSize = sizeof (NVIDIA_MEMORY_TEST_OPTIONS);
  PcdSetPtrS (PcdMemoryTest, &BufferSize, PcdGetPtr (PcdMemoryTest));

  // Initialize SOC display hand-off mode
  PcdSet8S (PcdSocDisplayHandoffMode, PcdGet8 (PcdSocDisplayHandoffMode));

  // Initialize Server Power Control settings
  PcdSet8S (PcdServerPowerControlSetting, PcdGet8 (PcdServerPowerControlSetting));

  // Initialize board recovery boot mode Form Settings
  if (PcdGetBool (PcdBoardRecoveryBoot)) {
    PcdSetBoolS (PcdBoardRecoveryBoot, FALSE);
    ValidateActiveBootChain ();
    SetNextBootRecovery ();
    DEBUG ((DEBUG_ERROR, "%a: Rebooting into recovery.\r\n", __FUNCTION__));
    StatusRegReset ();
    gRT->ResetSystem (EfiResetCold, EFI_SUCCESS, 0, NULL);
  }

  PcdSetBoolS (PcdBoardRecoveryBoot, FALSE);

  // Initialize Kernel Command Line Form Setting
  KernelCmdLineLen = 0;
  Status           = gRT->GetVariable (L"KernelCommandLine", &gNVIDIAPublicVariableGuid, NULL, &KernelCmdLineLen, NULL);
  if (Status == EFI_NOT_FOUND) {
    KernelCmdLineLen = 0;
  } else if (Status != EFI_BUFFER_TOO_SMALL) {
    DEBUG ((DEBUG_ERROR, "%a: Error Requesting command line variable %r\r\n", __FUNCTION__, Status));
    KernelCmdLineLen = 0;
  }

  if (KernelCmdLineLen < sizeof (CmdLine)) {
    KernelCmdLineLen = sizeof (CmdLine);
    ZeroMem (&CmdLine, KernelCmdLineLen);
    Status = gRT->SetVariable (L"KernelCommandLine", &gNVIDIAPublicVariableGuid, EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS, KernelCmdLineLen, (VOID *)&CmdLine);
    if (EFI_ERROR (Status)) {
      DEBUG ((DEBUG_ERROR, "%a: Error setting command line variable %r\r\n", __FUNCTION__, Status));
    }
  }

  ProductInfoLen = 0;

  Status = gRT->GetVariable (ProductInfoVariableName, &gNVIDIAPublicVariableGuid, NULL, &ProductInfoLen, NULL);
  if (Status == EFI_NOT_FOUND) {
    ProductInfoLen = 0;
  } else if (Status != EFI_BUFFER_TOO_SMALL) {
    DEBUG ((DEBUG_ERROR, "%a: Error Requesting %s variable %r\r\n", __FUNCTION__, ProductInfoVariableName, Status));
    ProductInfoLen = 0;
  }

  if (ProductInfoLen < sizeof (ProductInfo)) {
    ProductInfoLen = sizeof (ProductInfo);
    ZeroMem (&ProductInfo, ProductInfoLen);
    Status = gRT->SetVariable (ProductInfoVariableName, &gNVIDIAPublicVariableGuid, EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS, ProductInfoLen, (VOID *)&ProductInfo);
    if (EFI_ERROR (Status)) {
      DEBUG ((DEBUG_ERROR, "%a: Error setting %s variable %r\r\n", __FUNCTION__, ProductInfoVariableName, Status));
    }
  }

  BufferSize = sizeof (mHiiControlSettings.RootfsRedundancyLevel);
  Status     = gRT->GetVariable (
                      L"RootfsRedundancyLevel",
                      &gNVIDIAPublicVariableGuid,
                      NULL,
                      &BufferSize,
                      &mHiiControlSettings.RootfsRedundancyLevel
                      );
  if (EFI_ERROR (Status)) {
    mHiiControlSettings.RootfsRedundancyLevel = 0;
  }

  BufferSize = sizeof (mOpRomDisMask);
  Status     = gRT->GetVariable (
                      L"OpRomDisSegMask",
                      &gNVIDIAPublicVariableGuid,
                      NULL,
                      &BufferSize,
                      &mOpRomDisMask
                      );
  if (EFI_ERROR (Status)) {
    mOpRomDisMask = 0;
  }

  BufferSize = sizeof (mMaxPayloadSize);

  Status = gRT->GetVariable (
                  L"PcieMaxPayloadSize",
                  &gNVIDIAPublicVariableGuid,
                  NULL,
                  &BufferSize,
                  &mMaxPayloadSize
                  );
  if (EFI_ERROR (Status)) {
    ZeroMem (mMaxPayloadSize, sizeof (mMaxPayloadSize));
  }

  BufferSize = sizeof (mExt10bitTagReqEnable);
  Status     = gRT->GetVariable (
                      L"Ext10bitTagReq",
                      &gNVIDIAPublicVariableGuid,
                      NULL,
                      &BufferSize,
                      &mExt10bitTagReqEnable
                      );
  if (EFI_ERROR (Status)) {
    mExt10bitTagReqEnable = 0;
  }

  mHiiControlSettings.L4TSupported                     = PcdGetBool (PcdL4TConfigurationSupport);
  mHiiControlSettings.QuickBootSupported               = FeaturePcdGet (PcdQuickBootSupported);
  mHiiControlSettings.DebugMenuSupported               = FeaturePcdGet (PcdDebugMenuSupport);
  mHiiControlSettings.RedfishSupported                 = FeaturePcdGet (PcdRedfishSupported);
  mHiiControlSettings.TpmPresent                       = PcdGetBool (PcdTpmPresent);
  mHiiControlSettings.MemoryTestsSupported             = PcdGetBool (PcdMemoryTestsSupported);
  mHiiControlSettings.NvDisplayHandoffControlSupported = PcdGetBool (PcdNvGopSupported) && !AcpiMode;

  HobPointer = GetFirstGuidHob (&gNVIDIATH500MB1DataGuid);
  if (HobPointer != NULL) {
    if ((GET_GUID_HOB_DATA_SIZE (HobPointer) == (sizeof (TEGRABL_EARLY_BOOT_VARIABLES) * MAX_SOCKETS))) {
      TH500HobConfig                  = (CONST TEGRABL_EARLY_BOOT_VARIABLES *)GET_GUID_HOB_DATA (HobPointer);
      mHiiControlSettings.TH500Config = TRUE;
      CopyMem (&mMb1Config, TH500HobConfig, sizeof (TEGRABL_EARLY_BOOT_VARIABLES));

      // Check versions
      if (mMb1Config.Data.Mb1Data.Header.MajorVersion > TEGRABL_MB1_BCT_MAJOR_VERSION) {
        // We don't support this so disable settings
        mHiiControlSettings.TH500Config = FALSE;
      } else if ((mMb1Config.Data.Mb1Data.Header.MajorVersion == TEGRABL_MB1_BCT_MAJOR_VERSION) &&
                 (mMb1Config.Data.Mb1Data.Header.MinorVersion > TEGRABL_MB1_BCT_MINOR_VERSION))
      {
        // Force to common supported version
        mMb1Config.Data.Mb1Data.Header.MinorVersion = TEGRABL_MB1_BCT_MINOR_VERSION;
      }
    } else {
      DEBUG ((DEBUG_ERROR, "%a: Unexpected size of TH500 MB1 Data HOB\r\n", __FUNCTION__));
    }
  }

  HobPointer = GetFirstGuidHob (&gNVIDIATH500MB1DefaultDataGuid);
  if (HobPointer != NULL) {
    if ((GET_GUID_HOB_DATA_SIZE (HobPointer) == (sizeof (TEGRABL_EARLY_BOOT_VARIABLES) * MAX_SOCKETS))) {
      TH500HobConfig = (CONST TEGRABL_EARLY_BOOT_VARIABLES *)GET_GUID_HOB_DATA (HobPointer);
      CopyMem (&mMb1DefaultConfig, TH500HobConfig, sizeof (TEGRABL_EARLY_BOOT_VARIABLES));
    } else {
      DEBUG ((DEBUG_ERROR, "%a: Unexpected size of TH500 MB1 Default Data HOB\r\n", __FUNCTION__));
    }
  }

  for (Index = 0; Index < MAX_SOCKETS; Index++) {
    mHiiControlSettings.SocketEnabled[Index] = IsSocketEnabled (Index);
  }

  if (mHiiControlSettings.TH500Config) {
    WriteFloorsweepingVariables ();

    DiscardVariableOverrides = FALSE;
    Status                   = AccessMb1Record (&mLastWrittenMb1Config, FALSE);
    if (EFI_ERROR (Status)) {
      // No last written mb1 config present. Initialize with mMb1Config.
      DiscardVariableOverrides = TRUE;
      CopyMem (&mLastWrittenMb1Config, &mMb1Config, sizeof (TEGRABL_EARLY_BOOT_VARIABLES));
      Status = AccessMb1Record (&mLastWrittenMb1Config, TRUE);
      if (EFI_ERROR (Status)) {
        return;
      }

      DEBUG ((DEBUG_ERROR, "%a: No last Written Mb1 Config: Variable overrides would be discarded\r\n", __FUNCTION__));
    }

    if ((!DiscardVariableOverrides) &&
        (CompareMem (&mMb1Config.Data.Mb1Data, &mLastWrittenMb1Config.Data.Mb1Data, sizeof (TH500_MB1_CONFIGURATION)) != 0))
    {
      // Current MB1 config does not match last written mb1 config
      DiscardVariableOverrides = TRUE;
      CopyMem (&mLastWrittenMb1Config, &mMb1Config, sizeof (TEGRABL_EARLY_BOOT_VARIABLES));
      Status = AccessMb1Record (&mLastWrittenMb1Config, TRUE);
      if (EFI_ERROR (Status)) {
        return;
      }

      DEBUG ((DEBUG_ERROR, "%a: New Mb1 Config Not matching last Written Mb1 Config: Variable overrides would be discarded\r\n", __FUNCTION__));
    }

    CopyMem (&mVariableMb1Config, &mLastWrittenMb1Config, sizeof (TEGRABL_EARLY_BOOT_VARIABLES));
    if (!DiscardVariableOverrides) {
      Status = ReadMb1Variables (&mVariableMb1Config);
      if (!EFI_ERROR (Status)) {
        if (CompareMem (&mVariableMb1Config, &mLastWrittenMb1Config, sizeof (TEGRABL_EARLY_BOOT_VARIABLES)) != 0) {
          Status = AccessMb1Record (&mVariableMb1Config, TRUE);
          if (!EFI_ERROR (Status)) {
            // Mark existing boot chain as good.
            ValidateActiveBootChain ();

            StatusRegReset ();
            gRT->ResetSystem (EfiResetCold, EFI_SUCCESS, 0, NULL);
            ASSERT (FALSE);
          }
        }
      }
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 20) {
      mHiiControlSettings.MaxAllowedNumSparesSupported         = TRUE;
      mHiiControlSettings.DisplayAllMaxAllowedNumSparesOptions = mMb1Config.Data.Mb1Data.FeatureData.DisplayAllSpareOptions;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 18) {
      mHiiControlSettings.HvEgmSizeSupported = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 17) {
      mHiiControlSettings.PCIeDisableL23AtWarmResetSupported = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 16) {
      mHiiControlSettings.PCIeOSNativeAERSupported = TRUE;
    }

    if ((mMb1Config.Data.Mb1Data.Header.MinorVersion >= 14) &&
        (mMb1Config.Data.Mb1Data.Header.MinorVersion <= 19))
    {
      mHiiControlSettings.DisableChannelSparingSupported = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 18) {
      mHiiControlSettings.EccAlgorithmSupported = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 11) {
      mHiiControlSettings.PCIeACSConfigSupported = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 9) {
      mHiiControlSettings.PCIeSlotNumConfigSupported = TRUE;
      mHiiControlSettings.PCIeURCAConfigSupported    = TRUE;
      mHiiControlSettings.PCIePRSNTConfigSupported   = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion <= 7) {
      mHiiControlSettings.PCIeASPML1SSConfigSupported = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 7) {
      mHiiControlSettings.EInjEnableSupported = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 6) {
      mHiiControlSettings.UartBaudRateSettingSupported = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 5) {
      mHiiControlSettings.ModsSpEnableSettingSupported = TRUE;
    }

    // Disable GPU SMMU Bypass Support Till RM Confirms Support
    // if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 4) {
    //  mHiiControlSettings.GpuSmmuBypassEnableSettingSupported = TRUE;
    //  if (mMb1Config.Data.Mb1Data.FeatureData.GpuSmmuBypassEnable == TRUE) {
    //    for (Index = 0; Index < MAX_SOCKETS; Index++) {
    //      if (!IsSocketEnabled (Index)) {
    //        continue;
    //      }
    //
    //      MmioWrite32 (
    //        (Index << TH500_SOCKET_SHFT) + TH500_MCF_SMMU_SOCKET_0 + TH500_MCF_SMMU_BYPASS_0_OFFSET,
    //        0x1
    //        );
    //    }
    //  }
    // }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 3) {
      mHiiControlSettings.TpmEnableSettingSupported = TRUE;
    }

    if ((mMb1Config.Data.Mb1Data.Header.MinorVersion >= 2) &&
        (mMb1Config.Data.Mb1Data.Header.MinorVersion <= 10))
    {
      mHiiControlSettings.PerfVersionSettingSupported = TRUE;
    }

    if (mHiiControlSettings.DebugMenuSupported) {
      mHiiControlSettings.UefiDebugLevel = mMb1Config.Data.Mb1Data.UefiDebugLevel;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 12) {
      mHiiControlSettings.ActiveCoresSettingSupported = TRUE;
    }

    if (mMb1Config.Data.Mb1Data.Header.MinorVersion >= 15) {
      mHiiControlSettings.MpamPartidConfigSupported = TRUE;
    }

    // Initialize Server Power Control
    Status = gBS->LocateProtocol (&gServerPowerControlProtocolGuid, NULL, (VOID **)&ServerPwrCtl);
    if (!EFI_ERROR (Status)) {
      mHiiControlSettings.ServerPwrCtlSettingSupported = TRUE;
      ServerPwrCtl->ConfigurePowerControl (ServerPwrCtl, PcdGet8 (PcdServerPowerControlSetting));
    }

    WriteMb1Variables (&mMb1Config, &mVariableMb1Config, DiscardVariableOverrides);
  }
}

/**
  This function allows a caller to extract the current configuration for one
  or more named elements from the target driver.

  @param[in]  This           Points to the EFI_HII_CONFIG_ACCESS_PROTOCOL.
  @param[in]  Request        A null-terminated Unicode string in
                             <ConfigRequest> format.
  @param[out] Progress       On return, points to a character in the Request
                             string. Points to the string's null terminator if
                             request was successful. Points to the most recent
                             '&' before the first failing name/value pair (or
                             the beginning of the string if the failure is in
                             the first name/value pair) if the request was not
                             successful.
  @param[out] Results        A null-terminated Unicode string in
                             <ConfigAltResp> format which has all values filled
                             in for the names in the Request string. String to
                             be allocated by the called function.

  @retval EFI_SUCCESS             The Results is filled with the requested
                                  values.
  @retval EFI_OUT_OF_RESOURCES    Not enough memory to store the results.
  @retval EFI_INVALID_PARAMETER   Request is illegal syntax, or unknown name.
  @retval EFI_NOT_FOUND           Routing data doesn't match any storage in
                                  this driver.

**/
EFI_STATUS
EFIAPI
ConfigExtractConfig (
  IN CONST EFI_HII_CONFIG_ACCESS_PROTOCOL  *This,
  IN CONST EFI_STRING                      Request,
  OUT EFI_STRING                           *Progress,
  OUT EFI_STRING                           *Results
  )
{
  EFI_STATUS  Status;
  UINTN       BufferSize;
  EFI_STRING  ConfigRequestHdr;
  EFI_STRING  ConfigRequest;
  BOOLEAN     AllocatedRequest;
  UINTN       Size;

  if ((This == NULL) || (Progress == NULL) || (Results == NULL)) {
    return EFI_INVALID_PARAMETER;
  }

  *Progress = Request;
  if ((Request != NULL) && !HiiIsConfigHdrMatch (Request, &gNVIDIAResourceConfigFormsetGuid, mHiiControlStorageName)) {
    return EFI_NOT_FOUND;
  }

  ConfigRequestHdr = NULL;
  ConfigRequest    = NULL;
  AllocatedRequest = FALSE;
  Size             = 0;

  //
  // Convert buffer data to <ConfigResp> by helper function BlockToConfig().
  //
  BufferSize    = sizeof (NVIDIA_CONFIG_HII_CONTROL);
  ConfigRequest = Request;
  if ((Request == NULL) || (StrStr (Request, L"OFFSET") == NULL)) {
    //
    // Request has no request element, construct full request string.
    // Allocate and fill a buffer large enough to hold the <ConfigHdr> template
    // followed by "&OFFSET=0&WIDTH=WWWWWWWWWWWWWWWW" followed by a Null-terminator
    //
    ConfigRequestHdr = HiiConstructConfigHdr (&gNVIDIAResourceConfigFormsetGuid, mHiiControlStorageName, mDriverHandle);
    if (ConfigRequestHdr == NULL) {
      return EFI_OUT_OF_RESOURCES;
    }

    Size          = (StrLen (ConfigRequestHdr) + 32 + 1) * sizeof (CHAR16);
    ConfigRequest = AllocateZeroPool (Size);
    if (ConfigRequest == NULL) {
      return EFI_OUT_OF_RESOURCES;
    }

    AllocatedRequest = TRUE;
    UnicodeSPrint (ConfigRequest, Size, L"%s&OFFSET=0&WIDTH=%016LX", ConfigRequestHdr, (UINT64)BufferSize);
    FreePool (ConfigRequestHdr);
  }

  SyncHiiSettings (TRUE);

  Status = gHiiConfigRouting->BlockToConfig (
                                gHiiConfigRouting,
                                ConfigRequest,
                                (UINT8 *)&mHiiControlSettings,
                                BufferSize,
                                Results,
                                Progress
                                );
  //
  // Free the allocated config request string.
  //
  if (AllocatedRequest) {
    FreePool (ConfigRequest);
    ConfigRequest = NULL;
  }

  //
  // Set Progress string to the original request string.
  //
  if (Request == NULL) {
    *Progress = NULL;
  } else if (StrStr (Request, L"OFFSET") == NULL) {
    *Progress = Request + StrLen (Request);
  }

  return Status;
}

/**
  This function processes the results of changes in configuration.

  @param[in]  This           Points to the EFI_HII_CONFIG_ACCESS_PROTOCOL.
  @param[in]  Configuration  A null-terminated Unicode string in <ConfigResp>
                             format.
  @param[out] Progress       A pointer to a string filled in with the offset of
                             the most recent '&' before the first failing
                             name/value pair (or the beginning of the string if
                             the failure is in the first name/value pair) or
                             the terminating NULL if all was successful.

  @retval EFI_SUCCESS             The Results is processed successfully.
  @retval EFI_INVALID_PARAMETER   Configuration is NULL.
  @retval EFI_NOT_FOUND           Routing data doesn't match any storage in
                                  this driver.

**/
EFI_STATUS
EFIAPI
ConfigRouteConfig (
  IN CONST EFI_HII_CONFIG_ACCESS_PROTOCOL  *This,
  IN CONST EFI_STRING                      Configuration,
  OUT EFI_STRING                           *Progress
  )
{
  EFI_STATUS  Status;
  UINTN       BufferSize;
  UINT32      StoredDbg2NetworkDevice;

  Status = EFI_SUCCESS;

  if ((This == NULL) || (Configuration == NULL) || (Progress == NULL)) {
    return EFI_INVALID_PARAMETER;
  }

  //
  // Check routing data in <ConfigHdr>.
  // Note: if only one Storage is used, then this checking could be skipped.
  //
  if (!HiiIsConfigHdrMatch (Configuration, &gNVIDIAResourceConfigFormsetGuid, mHiiControlStorageName)) {
    *Progress = Configuration;
    return EFI_NOT_FOUND;
  }

  //
  // Convert <ConfigResp> to buffer data by helper function ConfigToBlock().
  //
  BufferSize = sizeof (NVIDIA_CONFIG_HII_CONTROL);
  Status     = gHiiConfigRouting->ConfigToBlock (
                                    gHiiConfigRouting,
                                    Configuration,
                                    (UINT8 *)&mHiiControlSettings,
                                    &BufferSize,
                                    Progress
                                    );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  SyncHiiSettings (FALSE);

  if (mHiiControlSettings.TH500Config) {
    if (CompareMem (&mMb1Config, &mLastWrittenMb1Config, sizeof (TEGRABL_EARLY_BOOT_VARIABLES)) != 0) {
      Status = AccessMb1Record (&mMb1Config, TRUE);
      if (!EFI_ERROR (Status)) {
        CopyMem (&mLastWrittenMb1Config, &mMb1Config, sizeof (TEGRABL_EARLY_BOOT_VARIABLES));
        Status = WriteMb1Variables (&mMb1Config, &mVariableMb1Config, FALSE);
      }

      if (EFI_ERROR (Status)) {
        return Status;
      }
    }
  }

  Status = gRT->GetVariable (L"Dbg2NetworkDevice", &gNVIDIAPublicVariableGuid, NULL, &BufferSize, &StoredDbg2NetworkDevice);
  if (EFI_ERROR (Status) ||
      (BufferSize != sizeof (UINT32)) ||
      (StoredDbg2NetworkDevice != mHiiControlSettings.Dbg2NetworkDevice))
  {
    Status = gRT->SetVariable (
                    L"Dbg2NetworkDevice",
                    &gNVIDIAPublicVariableGuid,
                    EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS,
                    sizeof (UINT32),
                    &mHiiControlSettings.Dbg2NetworkDevice
                    );
    if (EFI_ERROR (Status)) {
      DEBUG ((DEBUG_ERROR, "%a: Failed to set Dbg2NetworkDevice variable %r\r\n", __FUNCTION__, Status));
    }
  }

  Status = gRT->SetVariable (
                  L"OpRomDisSegMask",
                  &gNVIDIAPublicVariableGuid,
                  EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS,
                  sizeof (mOpRomDisMask),
                  &mOpRomDisMask
                  );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  Status = gRT->SetVariable (
                  L"PcieMaxPayloadSize",
                  &gNVIDIAPublicVariableGuid,
                  EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS,
                  sizeof (mMaxPayloadSize),
                  &mMaxPayloadSize
                  );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  Status = gRT->SetVariable (
                  L"Ext10bitTagReq",
                  &gNVIDIAPublicVariableGuid,
                  EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS,
                  sizeof (mExt10bitTagReqEnable),
                  &mExt10bitTagReqEnable
                  );
  if (EFI_ERROR (Status)) {
    return Status;
  }

  return Status;
}

/**
  This function sets the default value based on type.

  @param[in]   Type           The type of value for the question.
  @param[in]   Data           The data to se set for value pointer.
  @param[out]  Value          A pointer to the data being sent to the original
                              exporting driver.

**/
VOID
SetTypedValue (
  IN     UINT8               Type,
  IN     UINT64              Data,
  OUT    EFI_IFR_TYPE_VALUE  *Value
  )
{
  if (Value == NULL) {
    return;
  }

  if (Type == EFI_IFR_TYPE_NUM_SIZE_8) {
    Value->u8 = Data;
  } else if (Type == EFI_IFR_TYPE_NUM_SIZE_16) {
    Value->u16 = Data;
  } else if (Type == EFI_IFR_TYPE_NUM_SIZE_32) {
    Value->u32 = Data;
  } else if (Type == EFI_IFR_TYPE_NUM_SIZE_64) {
    Value->u64 = Data;
  } else if (Type == EFI_IFR_TYPE_BOOLEAN) {
    Value->b = Data;
  }
}

/**
  This function returns question default value from MB1 variable.

  @param[in]   QuestionId          A unique value which is sent to the original
                                   exporting driver so that it can identify the type
                                   of data to expect.
  @param[in]   Type                The type of value for the question.
  @param[out]  Value               A pointer to the data being sent to the original
                                   exporting driver.

  @retval EFI_SUCCESS              Question default value is returned successfully.
  @retval EFI_INVALID_PARAMETER    Input argument invalid.

**/
EFI_STATUS
GetDefaultValue (
  IN     EFI_QUESTION_ID     QuestionId,
  IN     UINT8               Type,
  IN     EFI_IFR_TYPE_VALUE  *Value
  )
{
  UINT64  Data;
  UINTN   SocketIndex;
  UINTN   UphyIndex;
  UINTN   PcieIndex;

  if (Value == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  SocketIndex = 0;
  UphyIndex   = 0;
  PcieIndex   = 0;

  switch (QuestionId) {
    case KEY_ENABLE_TPM:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.TpmEnable;
      break;
    case KEY_ENABLE_EGM:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.EgmEnable;
      break;
    case KEY_EGM_HV_SIZE_MB:
      Data = mMb1DefaultConfig.Data.Mb1Data.HvRsvdMemSize;
      break;
    case KEY_SPREAD_SPECTRUM:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.SpreadSpecEnable;
      break;
    case KEY_MODS_SP_ENABLE:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.ModsSpEnable;
      break;
    case KEY_GPU_SMMU_BYPASS_ENABLE:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.GpuSmmuBypassEnable;
      break;
    case KEY_UART_BAUD_RATE:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.UartBaudRate;
      break;
    case KEY_PERF_VERSION:
      Data = mMb1DefaultConfig.Data.Mb1Data.PerfVersion;
      break;
    case KEY_EINJ_ENABLE:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.EInjEnable;
      break;
    case KEY_DISABLE_CHANNEL_SPARING:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.DisableChannelSparing;
      break;
    case KEY_ECC_ALGORITHM:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.EccAlgorithm;
      break;
    case KEY_MAX_ALLOWED_NUM_SPARES:
      Data = mMb1DefaultConfig.Data.Mb1Data.FeatureData.MaxAllowedNumSpares;
      break;
    case KEY_UEFI_DEBUG_LEVEL:
      Data = mMb1DefaultConfig.Data.Mb1Data.UefiDebugLevel;
      break;
    case KEY_SERIAL_PORT_CONFIG:
      Data = mDefaultPortConfig;
      break;
    case KEY_MAX_CORES:
      Data = 0;
      for (SocketIndex = 0; SocketIndex < TEGRABL_SOC_MAX_SOCKETS; SocketIndex++) {
        Data += mMb1DefaultConfig.Data.Mb1Data.ActiveCores[SocketIndex];
      }

      break;
    case KEY_DBG2_NETWORK_DEVICE:
      Data = MAX_UINT32;
      break;
    case KEY_MPAM40_CPOR_WAYMASK:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[0].CporWayMask;
      break;
    case KEY_MPAM41_CPOR_WAYMASK:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[1].CporWayMask;
      break;
    case KEY_MPAM42_CPOR_WAYMASK:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[2].CporWayMask;
      break;
    case KEY_MPAM43_CPOR_WAYMASK:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[3].CporWayMask;
      break;
    case KEY_MPAM44_CPOR_WAYMASK:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[4].CporWayMask;
      break;
    case KEY_MPAM40_MAX_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[0].MaxBw;
      break;
    case KEY_MPAM41_MAX_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[1].MaxBw;
      break;
    case KEY_MPAM42_MAX_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[2].MaxBw;
      break;
    case KEY_MPAM43_MAX_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[3].MaxBw;
      break;
    case KEY_MPAM44_MAX_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[4].MaxBw;
      break;
    case KEY_MPAM40_MIN_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[0].MinBw;
      break;
    case KEY_MPAM41_MIN_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[1].MinBw;
      break;
    case KEY_MPAM42_MIN_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[2].MinBw;
      break;
    case KEY_MPAM43_MIN_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[3].MinBw;
      break;
    case KEY_MPAM44_MIN_BW:
      Data = mMb1DefaultConfig.Data.Mb1Data.MpamConfig[4].MinBw;
      break;
    case KEY_SERVER_POWER_CONTROL:
      Data = POWER_CTL_INPUT_PWR_CAPPING_50MS;
      break;
    case KEY_ENABLE_ACPI_TIMER:
      Data = 0;
      break;
    case KEY_EGM_HV_MIN_EGM_SIZE_MB:
      Data = mMb1DefaultConfig.Data.Mb1Data.HvMinEgmSize;
      break;
    case KEY_EGM_HV_VIRT_UEFI_SIZE_MB:
      Data = mMb1DefaultConfig.Data.Mb1Data.HvVirtUefiSize;
      break;
    default:
      //
      // UPHY
      //
      SocketIndex = 0;
      if ((QuestionId >= KEY_UPHY0_SOCKET0_CONFIG) && (QuestionId <= KEY_UPHY5_SOCKET3_CONFIG)) {
        SocketIndex = (QuestionId - KEY_UPHY0_SOCKET0_CONFIG) / TEGRABL_MAX_UPHY_PER_SOCKET;
        UphyIndex   = (QuestionId - KEY_UPHY0_SOCKET0_CONFIG) % TEGRABL_MAX_UPHY_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (UphyIndex >= TEGRABL_MAX_UPHY_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.UphyConfig.UphyConfig[SocketIndex][UphyIndex];
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_MAX_SPEED) && (QuestionId <= KEY_SOCKET3_PCIE9_MAX_SPEED)) {
        //
        // PCIE MAX SPEED
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_MAX_SPEED) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_MAX_SPEED) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].MaxSpeed;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_MAX_WIDTH) && (QuestionId <= KEY_SOCKET3_PCIE9_MAX_WIDTH)) {
        //
        // PCIE MAX WIDTH
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_MAX_WIDTH) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_MAX_WIDTH) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].MaxWidth;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_ADVERTISE_ASPML1) && (QuestionId <= KEY_SOCKET3_PCIE9_ADVERTISE_ASPML1)) {
        //
        // PCIE ADVERTISE ASPML1
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_ASPML1) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_ASPML1) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].AdvertiseAspmL1;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_ADVERTISE_ASPML1_1) && (QuestionId <= KEY_SOCKET3_PCIE9_ADVERTISE_ASPML1_1)) {
        //
        // PCIE ADVERTISE ASPML1_1
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_ASPML1_1) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_ASPML1_1) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].AdvertiseAspmL1_1;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_ADVERTISE_ASPML1_2) && (QuestionId <= KEY_SOCKET3_PCIE9_ADVERTISE_ASPML1_2)) {
        //
        // PCIE ADVERTISE ASPML1_2
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_ASPML1_2) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_ASPML1_2) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].AdvertiseAspmL1_2;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_ADVERTISE_PCIPML1_2) && (QuestionId <= KEY_SOCKET3_PCIE9_ADVERTISE_PCIPML1_2)) {
        //
        // PCIE ADVERTISE PCIPML1_2
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_PCIPML1_2) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_PCIPML1_2) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].AdvertisePciPmL1_2;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_CLK_REQ) && (QuestionId <= KEY_SOCKET3_PCIE9_CLK_REQ)) {
        //
        // PCIE CLK_REQ
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_CLK_REQ) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_CLK_REQ) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].SupportsClkReq;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_DISABLE_DLFE) && (QuestionId <= KEY_SOCKET3_PCIE9_DISABLE_DLFE)) {
        //
        // PCIE DISABLE_DLFE
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_DISABLE_DLFE) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_DISABLE_DLFE) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].DisableDLFE;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_ENABLE_ECRC) && (QuestionId <= KEY_SOCKET3_PCIE9_ENABLE_ECRC)) {
        //
        // PCIE ENABLE_ECRC
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_ENABLE_ECRC) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_ENABLE_ECRC) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].EnableECRC;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_DISABLE_OPT_ROM) && (QuestionId <= KEY_SOCKET3_PCIE9_DISABLE_OPT_ROM)) {
        //
        // PCIE DISABLE_OPT_ROM
        // mOpRomDisMaks is came from UEFI variable. When variable does not exist, mOpRomDisMaks is set to 0x0, which means
        // that the default value is 0x0.
        //
        Data = 0x0;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_DISABLE_DPC_AT_RP) && (QuestionId <= KEY_SOCKET3_PCIE9_DISABLE_DPC_AT_RP)) {
        //
        // PCIE ENABLE_ECRC
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_DISABLE_DPC_AT_RP) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_DISABLE_DPC_AT_RP) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].DisableDPCAtRP;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_MASK_UNSUPPORTED_REQUEST) && (QuestionId <= KEY_SOCKET3_PCIE9_MASK_UNSUPPORTED_REQUEST)) {
        //
        // PCIE MASK_UNSUPPORTED_REQUEST
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_MASK_UNSUPPORTED_REQUEST) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_MASK_UNSUPPORTED_REQUEST) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].MaskUnsupportedRequest;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_MASK_COMPLETER_ABORT) && (QuestionId <= KEY_SOCKET3_PCIE9_MASK_COMPLETER_ABORT)) {
        //
        // PCIE MASK_COMPLETER_ABORT
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_MASK_COMPLETER_ABORT) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_MASK_COMPLETER_ABORT) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].MaskCompleterAbort;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_SUPPORTS_PRSNT) && (QuestionId <= KEY_SOCKET3_PCIE9_SUPPORTS_PRSNT)) {
        //
        // PCIE SUPPORTS_PRSNT
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_SUPPORTS_PRSNT) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_SUPPORTS_PRSNT) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].SupportsPRSNT;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_MAX_PAYLOAD_SIZE) && (QuestionId <= KEY_SOCKET3_PCIE9_MAX_PAYLOAD_SIZE)) {
        //
        // PCIE MAX_PAYLOAD_SIZE
        //
        Data = 0x0;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_EXTENDED_10BIT_TAG_ENABLE) && (QuestionId <= KEY_SOCKET3_PCIE9_EXTENDED_10BIT_TAG_ENABLE)) {
        //
        // PCIE EXTENDED_10BIT_TAG_ENABLE
        //
        Data = 0x0;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_ADVERTISE_ACS) && (QuestionId <= KEY_SOCKET3_PCIE9_ADVERTISE_ACS)) {
        //
        // PCIE ADVERTISE_ACS
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_ACS) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_ADVERTISE_ACS) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].AdvertiseACS;
      } else if ((QuestionId >= KEY_SOCKET0_PCIE0_OS_NATIVE_AER) && (QuestionId <= KEY_SOCKET3_PCIE9_OS_NATIVE_AER)) {
        //
        // PCIE OS_NATIVE_AER
        //
        SocketIndex = (QuestionId - KEY_SOCKET0_PCIE0_OS_NATIVE_AER) / TEGRABL_MAX_PCIE_PER_SOCKET;
        PcieIndex   = (QuestionId - KEY_SOCKET0_PCIE0_OS_NATIVE_AER) % TEGRABL_MAX_PCIE_PER_SOCKET;
        if ((SocketIndex >= TEGRABL_SOC_MAX_SOCKETS) || (PcieIndex >= TEGRABL_MAX_PCIE_PER_SOCKET)) {
          ASSERT (FALSE);
          return EFI_PROTOCOL_ERROR;
        }

        Data = mMb1DefaultConfig.Data.Mb1Data.PcieConfig[SocketIndex][PcieIndex].OsNativeAER;
      } else {
        //
        // Unsupported question ID.
        //
        DEBUG ((DEBUG_INFO, "%a: unsupported question ID: 0x%x\n", __func__, QuestionId));
        return EFI_SUCCESS;
      }
  }

  SetTypedValue (Type, Data, Value);

  return EFI_SUCCESS;
}

/**
  Get total enabled cores count of all sockets

  @return UINT32         Total number of enabled cores
**/
UINT32
GetTotalEnabledCores (
  )
{
  UINT32  TotalEnabledCores = 0;

  for (UINT8 Index = 0; Index < MAX_SOCKETS; Index++) {
    DEBUG ((DEBUG_INFO, "MB1 Core socket 0x%x cores 0x%x\r\n", Index, mMb1DefaultConfig.Data.Mb1Data.ActiveCores[Index]));
    TotalEnabledCores += mMb1DefaultConfig.Data.Mb1Data.ActiveCores[Index];
  }

  return TotalEnabledCores;
}

/**
  Return whether an user input active core count is valid or not

  @param ActiveCores   User input core count

  @return BOOLEAN      Is the input valid or not
**/
BOOLEAN
IsActiveCoresValid (
  UINT32  ActiveCores
  )
{
  UINT32  TotalEnabledCores = 0;

  TotalEnabledCores = GetTotalEnabledCores ();
  return TotalEnabledCores ? (ActiveCores <= TotalEnabledCores) : TRUE;
}

/**
  Construct Request String (L"&OFFSET=%x&WIDTH=%x") base on the input Offset and Width.
  If the input RequestString is not NULL, new request will be cat at the end of it. The full
  request string will be constructed and return. Caller is responsible to free it.

  @param RequestString   Current request string.
  @param Offset          Offset of data in Storage.
  @param Width           Width of data.

  @return String         Request string with input Offset and Width.
**/
EFI_STRING
EFIAPI
HiiConstructRequestString (
  IN EFI_STRING RequestString, OPTIONAL
  IN UINTN           Offset,
  IN UINTN           Width
  )
{
  CHAR16      RequestElement[30];
  UINTN       StringLength = 0;
  EFI_STRING  NewString;

  StringLength = UnicodeSPrint (
                   RequestElement,
                   sizeof (RequestElement),
                   L"&OFFSET=%x&WIDTH=%x",
                   Offset,
                   Width
                   );

  if (RequestString != NULL) {
    StringLength = StringLength + StrLen (RequestString);
  }

  NewString = AllocateZeroPool ((StringLength + 1) * sizeof (CHAR16));

  if (NewString == NULL) {
    if (RequestString != NULL) {
      FreePool (RequestString);
    }

    return NULL;
  }

  if (RequestString != NULL) {
    StrCatS (NewString, StringLength + 1, RequestString);
    FreePool (RequestString);
  }

  StrCatS (NewString, StringLength + 1, RequestElement);
  return NewString;
}

/**
  This function processes the results of changes in configuration.

  @param[in]  This           Points to the EFI_HII_CONFIG_ACCESS_PROTOCOL.
  @param[in]  Action         Specifies the type of action taken by the browser.
  @param[in]  QuestionId     A unique value which is sent to the original
                             exporting driver so that it can identify the type
                             of data to expect.
  @param[in]  Type           The type of value for the question.
  @param[in]  Value          A pointer to the data being sent to the original
                             exporting driver.
  @param[out] ActionRequest  On return, points to the action requested by the
                             callback function.

  @retval EFI_SUCCESS             The callback successfully handled the action.
  @retval EFI_OUT_OF_RESOURCES    Not enough storage is available to hold the
                                  variable and its data.
  @retval EFI_DEVICE_ERROR        The variable could not be saved.
  @retval EFI_UNSUPPORTED         The specified Action is not supported by the
                                  callback.

**/
EFI_STATUS
EFIAPI
ConfigCallback (
  IN CONST EFI_HII_CONFIG_ACCESS_PROTOCOL  *This,
  IN     EFI_BROWSER_ACTION                Action,
  IN     EFI_QUESTION_ID                   QuestionId,
  IN     UINT8                             Type,
  IN     EFI_IFR_TYPE_VALUE                *Value,
  OUT EFI_BROWSER_ACTION_REQUEST           *ActionRequest
  )
{
  EFI_STATUS                 Status;
  EFI_INPUT_KEY              InputKey;
  EFI_STRING                 TpmPopupTitle;
  EFI_STRING                 TpmPopupBody1;
  EFI_STRING                 TpmPopupBody2;
  EFI_STRING                 TpmPopupBody3;
  EFI_STRING                 TpmPopupConfirm;
  UINT32                     TotalEnabledCores = 0;
  EFI_INPUT_KEY              Key;
  CHAR16                     StringBuffer[50]        = { L'\0' };
  EFI_STRING                 RequestString           = NULL;
  NVIDIA_CONFIG_HII_CONTROL  *NvidiaConfigHiiControl = NULL;
  UINTN                      VarSize                 = sizeof (*NvidiaConfigHiiControl);

  Status = EFI_UNSUPPORTED;
  if ((Action == EFI_BROWSER_ACTION_FORM_OPEN) ||
      (Action == EFI_BROWSER_ACTION_FORM_CLOSE))
  {
    //
    // Do nothing for UEFI OPEN/CLOSE Action
    //
    Status = EFI_SUCCESS;
  } else if (Action == EFI_BROWSER_ACTION_CHANGED) {
    switch (QuestionId) {
      case KEY_RESET_VARIABLES:
        Status = FwVariableDeleteAll ();
        if (Status != EFI_OUT_OF_RESOURCES) {
          Status = EFI_SUCCESS;
        }

        //
        // Popup a menu to notice user and prompt for reset
        //
        do {
          CreatePopUp (
            EFI_LIGHTGRAY | EFI_BACKGROUND_BLUE,
            &InputKey,
            L"Settings have been reset to defaults",
            L"Press ENTER to reboot",
            NULL
            );
        } while (InputKey.UnicodeChar != CHAR_CARRIAGE_RETURN);

        // Mark existing boot chain as good.
        ValidateActiveBootChain ();

        StatusRegReset ();
        gRT->ResetSystem (EfiResetCold, EFI_SUCCESS, 0, NULL);
        break;
      case KEY_MAX_CORES:
        TotalEnabledCores = GetTotalEnabledCores ();
        if (!IsActiveCoresValid (Value->u32)) {
          UnicodeSPrint (StringBuffer, sizeof (StringBuffer), L"Max ActiveCores can't exceed %d", TotalEnabledCores);
          CreatePopUp (EFI_LIGHTGRAY | EFI_BACKGROUND_BLUE, &Key, StringBuffer, NULL);
          NvidiaConfigHiiControl = AllocatePool (VarSize);
          if (NvidiaConfigHiiControl == NULL) {
            return EFI_NOT_FOUND;
          }

          Status = HiiGetBrowserData (&gNVIDIAResourceConfigFormsetGuid, mHiiControlStorageName, VarSize, (UINT8 *)NvidiaConfigHiiControl);
          if (Status != TRUE) {
            FreePool (NvidiaConfigHiiControl);
            return EFI_NOT_FOUND;
          }

          // Restore to previous activecores
          NvidiaConfigHiiControl->ActiveCores = 0;
          for (UINT8 Index = 0; Index < MAX_SOCKETS; Index++) {
            NvidiaConfigHiiControl->ActiveCores += mMb1Config.Data.Mb1Data.ActiveCores[Index];
          }

          RequestString = HiiConstructRequestString (RequestString, OFFSET_OF (NVIDIA_CONFIG_HII_CONTROL, ActiveCores), sizeof (UINT32));
          Status        = HiiSetBrowserData (&gNVIDIAResourceConfigFormsetGuid, mHiiControlStorageName, VarSize, (UINT8 *)NvidiaConfigHiiControl, RequestString);
          if (Status != TRUE) {
            FreePool (NvidiaConfigHiiControl);
            return EFI_NOT_FOUND;
          }

          FreePool (NvidiaConfigHiiControl);
          if (RequestString) {
            FreePool (RequestString);
          }
        }

        break;
      default:
        break;
    }
  } else if (Action == EFI_BROWSER_ACTION_CHANGING) {
    switch (QuestionId) {
      case KEY_ENABLE_TPM:
        if (Value->u8 == 1) {
          TpmPopupTitle   = HiiGetString (mHiiHandle, STRING_TOKEN (STR_TPM_ENABLE_POPUP_TITLE), NULL);
          TpmPopupBody1   = HiiGetString (mHiiHandle, STRING_TOKEN (STR_TPM_ENABLE_POPUP_BODY_1), NULL);
          TpmPopupBody2   = HiiGetString (mHiiHandle, STRING_TOKEN (STR_TPM_ENABLE_POPUP_BODY_2), NULL);
          TpmPopupBody3   = HiiGetString (mHiiHandle, STRING_TOKEN (STR_TPM_ENABLE_POPUP_BODY_3), NULL);
          TpmPopupConfirm = HiiGetString (mHiiHandle, STRING_TOKEN (STR_TPM_ENABLE_POPUP_CONFIRM), NULL);

          CreatePopUp (
            EFI_LIGHTGRAY | EFI_BACKGROUND_BLUE,
            &InputKey,
            TpmPopupTitle,
            L"",
            TpmPopupBody1,
            TpmPopupBody2,
            TpmPopupBody3,
            L"",
            TpmPopupConfirm,
            NULL
            );

          // If user enters any character other than 'y', revert the option to "Disabled"
          if ((InputKey.UnicodeChar == L'Y') || (InputKey.UnicodeChar == L'y')) {
            Status = EFI_SUCCESS;
          } else {
            Status = EFI_OUT_OF_RESOURCES;
          }

          FreePool (TpmPopupTitle);
          FreePool (TpmPopupBody1);
          FreePool (TpmPopupBody2);
          FreePool (TpmPopupBody3);
          FreePool (TpmPopupConfirm);
        }

        break;

      default:
        break;
    }
  } else if ((Action == EFI_BROWSER_ACTION_DEFAULT_STANDARD) ||
             (Action == EFI_BROWSER_ACTION_DEFAULT_MANUFACTURING) ||
             (Action == EFI_BROWSER_ACTION_DEFAULT_SAFE) ||
             (Action == EFI_BROWSER_ACTION_DEFAULT_PLATFORM) ||
             (Action == EFI_BROWSER_ACTION_DEFAULT_HARDWARE) ||
             (Action == EFI_BROWSER_ACTION_DEFAULT_FIRMWARE))
  {
    //
    // Return default value of input question
    //
    Status = GetDefaultValue (QuestionId, Type, Value);
  }

  return Status;
}

// Build the DBG2 ethernet table if supported
STATIC
VOID
EFIAPI
UpdateDbg2Table (
  VOID
  )
{
  EFI_STATUS                         Status;
  VOID                               *StartOpCodeHandle;
  VOID                               *EndOpCodeHandle;
  EFI_IFR_GUID_LABEL                 *StartGuidLabel;
  EFI_IFR_GUID_LABEL                 *EndGuidLabel;
  EFI_GUID                           FormsetGuid = NVIDIA_CONFIG_FORMSET_GUID;
  EFI_HANDLE                         *HandleBuffer;
  UINTN                              NumberOfHandles;
  VOID                               *OptionsOpCodeHandle;
  UINT32                             Index;
  UINT32                             BarIndex;
  EFI_PCI_IO_PROTOCOL                *PciIo;
  PCI_TYPE00                         PciData;
  EFI_ACPI_ADDRESS_SPACE_DESCRIPTOR  *MmioDesc;
  BOOLEAN                            MemoryRegionSupported;
  BOOLEAN                            FoundSupportedNic;
  EFI_STRING_ID                      StringToken;
  CHAR16                             StringBuffer[MAX_DBG2_STRING_LENGTH];
  UINTN                              SegmentNumber;
  UINTN                              BusNumber;
  UINTN                              DeviceNumber;
  UINTN                              FunctionNumber;
  BOOLEAN                            ResetRequired;
  UINTN                              DataSize;

  FoundSupportedNic = FALSE;
  ResetRequired     = FALSE;

  DataSize = sizeof (mHiiControlSettings.Dbg2NetworkDevice);
  Status   = gRT->GetVariable (
                    L"Dbg2NetworkDevice",
                    &gNVIDIAPublicVariableGuid,
                    NULL,
                    &DataSize,
                    &mHiiControlSettings.Dbg2NetworkDevice
                    );
  if (!EFI_ERROR (Status) && (DataSize == sizeof (UINT32)) && (mHiiControlSettings.Dbg2NetworkDevice != MAX_UINT32)) {
    // Mark a reset required, will clear if the option is present.
    ResetRequired = TRUE;
  } else {
    mHiiControlSettings.Dbg2NetworkDevice = MAX_UINT32;
  }

  //
  // Init OpCode Handle and Allocate space for creation of UpdateData Buffer
  //
  OptionsOpCodeHandle = HiiAllocateOpCodeHandle ();
  ASSERT (OptionsOpCodeHandle != NULL);

  //
  // Allocate space for creation of UpdateData Buffer
  //
  StartOpCodeHandle = HiiAllocateOpCodeHandle ();
  ASSERT (StartOpCodeHandle != NULL);

  EndOpCodeHandle = HiiAllocateOpCodeHandle ();
  ASSERT (EndOpCodeHandle != NULL);
  //
  // Create Hii Extend Label OpCode as the start opcode
  //
  StartGuidLabel               = (EFI_IFR_GUID_LABEL *)HiiCreateGuidOpCode (StartOpCodeHandle, &gEfiIfrTianoGuid, NULL, sizeof (EFI_IFR_GUID_LABEL));
  StartGuidLabel->ExtendOpCode = EFI_IFR_EXTEND_OP_LABEL;
  StartGuidLabel->Number       = LABEL_DBG2_PCIE_DEVICE_START;
  //
  // Create Hii Extend Label OpCode as the end opcode
  //
  EndGuidLabel               = (EFI_IFR_GUID_LABEL *)HiiCreateGuidOpCode (EndOpCodeHandle, &gEfiIfrTianoGuid, NULL, sizeof (EFI_IFR_GUID_LABEL));
  EndGuidLabel->ExtendOpCode = EFI_IFR_EXTEND_OP_LABEL;
  EndGuidLabel->Number       = LABEL_DBG2_PCIE_DEVICE_END;

  Status = gBS->LocateHandleBuffer (ByProtocol, &gEfiPciIoProtocolGuid, NULL, &NumberOfHandles, &HandleBuffer);
  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_INFO, "%a: No PCI devices found - %r\r\n", __func__, Status));
    goto CleanupAndReturn;
  }

  for (Index = 0; Index < NumberOfHandles; Index++) {
    Status = gBS->HandleProtocol (HandleBuffer[Index], &gEfiPciIoProtocolGuid, (VOID **)&PciIo);
    if (EFI_ERROR (Status)) {
      continue;
    }

    Status = PciIo->Pci.Read (PciIo, EfiPciIoWidthUint8, 0, sizeof (PciData), &PciData);
    if (EFI_ERROR (Status)) {
      continue;
    }

    Status = PciIo->GetLocation (PciIo, &SegmentNumber, &BusNumber, &DeviceNumber, &FunctionNumber);
    if (EFI_ERROR (Status)) {
      continue;
    }

    if (SegmentNumber != 0) {
      continue;
    }

    if ((PciData.Hdr.ClassCode[2] != PCI_CLASS_NETWORK) || (PciData.Hdr.ClassCode[1] != PCI_CLASS_NETWORK_ETHERNET)) {
      continue;
    }

    MemoryRegionSupported = FALSE;
    for (BarIndex = 0; BarIndex < PCI_MAX_BAR; BarIndex++) {
      Status = PciIo->GetBarAttributes (PciIo, BarIndex, NULL, (VOID **)&MmioDesc);
      if (EFI_ERROR (Status) ||
          (MmioDesc->ResType != ACPI_ADDRESS_SPACE_TYPE_MEM))
      {
        continue;
      }

      // Don't support devices with memory translation enabled.
      if (MmioDesc->AddrTranslationOffset != 0) {
        MemoryRegionSupported = FALSE;
        break;
      }

      MemoryRegionSupported = TRUE;
    }

    if (!MemoryRegionSupported) {
      continue;
    }

    FoundSupportedNic = TRUE;

    UnicodeSPrint (
      StringBuffer,
      sizeof (StringBuffer),
      L"PCIe Device %04x:%04x [Segment %d Bus %d Device %d Function %d]",
      PciData.Hdr.VendorId,
      PciData.Hdr.DeviceId,
      SegmentNumber,
      BusNumber,
      DeviceNumber,
      FunctionNumber
      );
    StringToken = HiiSetString (mHiiHandle, 0, StringBuffer, NULL);
    // Create redfish token as well
    HiiSetString (mHiiHandle, StringToken, StringBuffer, "x-uefi-redfish-Bios.v1_2_0");
    HiiCreateOneOfOptionOpCode (
      OptionsOpCodeHandle,
      StringToken,
      0,
      EFI_IFR_NUMERIC_SIZE_4,
      SegmentNumber << 24 | BusNumber << 16 | DeviceNumber << 8 | FunctionNumber
      );

    // Check if the selected device is present and do not reset if it is.
    if (ResetRequired &&
        (mHiiControlSettings.Dbg2NetworkDevice == (SegmentNumber << 24 | BusNumber << 16 | DeviceNumber << 8 | FunctionNumber)))
    {
      ResetRequired = FALSE;
    }
  }

  if (ResetRequired) {
    mHiiControlSettings.Dbg2NetworkDevice = MAX_UINT32;
    gRT->SetVariable (
           L"Dbg2NetworkDevice",
           &gNVIDIAPublicVariableGuid,
           EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS,
           0,
           NULL
           );
  }

  if (!FoundSupportedNic) {
    goto CleanupAndReturn;
  }

  HiiCreateOneOfOptionOpCode (
    OptionsOpCodeHandle,
    STRING_TOKEN (STR_NONE),
    EFI_IFR_OPTION_DEFAULT,
    EFI_IFR_NUMERIC_SIZE_4,
    MAX_UINT32
    );

  HiiCreateOneOfOpCode (
    StartOpCodeHandle,
    KEY_DBG2_NETWORK_DEVICE,
    NVIDIA_CONFIG_HII_CONTROL_ID,
    OFFSET_OF (NVIDIA_CONFIG_HII_CONTROL, Dbg2NetworkDevice),
    STRING_TOKEN (STR_DBG2_NETWORK_DEVICE),
    STRING_TOKEN (STR_DBG2_NETWORK_DEVICE_HELP),
    EFI_IFR_FLAG_RESET_REQUIRED,
    EFI_IFR_NUMERIC_SIZE_4,
    OptionsOpCodeHandle,
    NULL
    );

  HiiUpdateForm (
    mHiiHandle,
    &FormsetGuid,
    NVIDIA_CONFIG_FORM_ID,
    StartOpCodeHandle,
    EndOpCodeHandle
    );

CleanupAndReturn:
  HiiFreeOpCodeHandle (OptionsOpCodeHandle);
  HiiFreeOpCodeHandle (StartOpCodeHandle);
  HiiFreeOpCodeHandle (EndOpCodeHandle);
}

VOID
EFIAPI
OnEndOfDxe (
  IN EFI_EVENT  Event,
  IN VOID       *Context
  )
{
  EFI_STATUS  Status;

  gBS->CloseEvent (Event);

  InitializeSettings ();

  mConfigAccess.Callback      = ConfigCallback;
  mConfigAccess.ExtractConfig = ConfigExtractConfig;
  mConfigAccess.RouteConfig   = ConfigRouteConfig;

  mDriverHandle = NULL;
  Status        = gBS->InstallMultipleProtocolInterfaces (
                         &mDriverHandle,
                         &gEfiDevicePathProtocolGuid,
                         &mNvidiaConfigHiiVendorDevicePath,
                         &gEfiHiiConfigAccessProtocolGuid,
                         &mConfigAccess,
                         NULL
                         );
  if (!EFI_ERROR (Status)) {
    mHiiHandle = HiiAddPackages (
                   &gNVIDIAResourceConfigFormsetGuid,
                   mDriverHandle,
                   NvidiaConfigDxeStrings,
                   NvidiaConfigHiiBin,
                   NULL
                   );

    if (mHiiHandle == NULL) {
      gBS->UninstallMultipleProtocolInterfaces (
             mDriverHandle,
             &gEfiDevicePathProtocolGuid,
             &mNvidiaConfigHiiVendorDevicePath,
             &gEfiHiiConfigAccessProtocolGuid,
             &mConfigAccess,
             NULL
             );
    } else {
      UpdateDbg2Table ();
    }
  }
}

/**
  Update Serial Port PCDs.
**/
STATIC
EFI_STATUS
UpdateSerialPcds (
  VOID
  )
{
  UINT8           SerialPortType;
  EFI_STATUS      Status;
  UINTN           SerialPortVarLen;
  SERIAL_MAPPING  *SerialMapping;

  SerialPortType = NVIDIA_SERIAL_PORT_TYPE_UNDEFINED;

  SerialPortIdentify (&SerialMapping);
  for ( ; SerialMapping->Type != TEGRA_UART_TYPE_NONE; SerialMapping++) {
    if (SerialMapping->IsFound) {
      if (SerialMapping->Type == TEGRA_UART_TYPE_16550) {
        SerialPortType     = NVIDIA_SERIAL_PORT_TYPE_16550;
        mDefaultPortConfig = NVIDIA_SERIAL_PORT_SPCR_FULL_16550;
        break;
      } else if (SerialMapping->Type == TEGRA_UART_TYPE_SBSA) {
        SerialPortType     = NVIDIA_SERIAL_PORT_TYPE_SBSA;
        mDefaultPortConfig = NVIDIA_SERIAL_PORT_SPCR_SBSA;
        break;
      }
    }
  }

  PcdSet8S (PcdSerialTypeConfig, SerialPortType);

  SerialPortVarLen = 0;
  Status           = gRT->GetVariable (L"SerialPortConfig", &gNVIDIATokenSpaceGuid, NULL, &SerialPortVarLen, NULL);
  if (Status == EFI_NOT_FOUND) {
    PcdSet8S (PcdSerialPortConfig, mDefaultPortConfig);
  }

  return EFI_SUCCESS;
}

/**
  Install NVIDIA Config driver.

  @param  ImageHandle     The image handle.
  @param  SystemTable     The system table.

  @retval EFI_SUCEESS     Install Boot manager menu success.
  @retval Other           Return error status.

**/
EFI_STATUS
EFIAPI
NvidiaConfigDxeInitialize (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  EFI_STATUS  Status;
  EFI_EVENT   EndOfDxeEvent;

  UpdateSerialPcds ();

  Status = gBS->CreateEventEx (
                  EVT_NOTIFY_SIGNAL,
                  TPL_CALLBACK,
                  OnEndOfDxe,
                  NULL,
                  &gEfiEndOfDxeEventGroupGuid,
                  &EndOfDxeEvent
                  );

  return Status;
}
